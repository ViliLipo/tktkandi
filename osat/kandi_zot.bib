
@inproceedings{davis_case_2017,
	address = {New York, NY, USA},
	series = {{EuroSec}'17},
	title = {The {Case} of the {Poisoned} {Event} {Handler}: {Weaknesses} in the {Node}.{Js} {Event}-{Driven} {Architecture}},
	isbn = {978-1-4503-4935-2},
	shorttitle = {The {Case} of the {Poisoned} {Event} {Handler}},
	doi = {10.1145/3065913.3065916},
	abstract = {Node.js has seen rapid adoption in industry and the open-source community. Unfortunately, its event-driven architecture exposes Node.js applications to Event Handler-Poisoning denial of service attacks. Our evaluation of the state of practice in Node.js--- combining a study of 353 publicly reported security vulnerabilities and a survey of 151 representative npm modules --- demonstrates that the community is not equipped to combat this class of attack. We recommend several changes to the state of practice and propose both programming language and runtime approaches to defend against Event Handler-Poisoning attacks.},
	booktitle = {Proceedings of the 10th {European} {Workshop} on {Systems} {Security}},
	publisher = {ACM},
	author = {Davis, James and Kildow, Gregor and Lee, Dongyoon},
	year = {2017},
	keywords = {Denial of service, Event-driven architecture, Node.js, ReDoS},
	pages = {8:1--8:6},
	annote = {Tietoturva kohtainen, mutta lähteet arvokkaat myös minulle.},
	file = {ACM Full Text PDF:/home/vili/Zotero/storage/DX3958A8/Davis et al. - 2017 - The Case of the Poisoned Event Handler Weaknesses.pdf:application/pdf}
}
@inproceedings{pai_flash_1999,
 author = {Pai, Vivek S. and Druschel, Peter and Zwaenepoel, Willy},
 title = {Flash: An Efficient and Portable Web Server},
 booktitle = {Proceedings of the Annual Conference on USENIX Annual Technical Conference},
 series = {ATEC '99},
 year = {1999},
 location = {Monterey, California},
 pages = {15--15},
 numpages = {1},
 acmid = {1268723},
 publisher = {USENIX Association},
 address = {Berkeley, CA, USA},
} 

@inproceedings{hu_applying_1998,
	title = {Applying {The} {Proactor} {Pattern} {To} {High}-{Performance} {Web} {Servers}},
	abstract = {Modern operating systems provide multiple concurrency mechanisms to develop high-performance Web servers. Synchronous multi-threading is a popular mechanism for developing Web servers that must perform multiple operations simultaneously to meet their performance requirements. In addition, an increasing number of operating systems support asynchronous mechanisms that provide the benefits of concurrency, while alleviating much of the performance overhead of synchronous multi-threading. This paper provides two contributions to the study of high-performance Web servers. First, it examines how synchronous and asynchronous event dispatching mechanisms impact the design and performance of JAWS, which is our high-performance Web server framework. The results reveal significant performance improvements when a proactive concurrency model is used to combine lightweight concurrency with asynchronous event dispatching. In general, however, the complexity of the proactive concurrency model makes it ...},
	booktitle = {{Proceedings} of the 10th {International} {Conference} on {Parallel} and {Distributed} {Computing} and {Systems}},
	author = {Hu, James and Pyarali, Irfan and Schmidt, Douglas C.},
	year = {1998},
	file = {Citeseer - Full Text PDF:/home/vililipo/Zotero/storage/59DS4828/Hu et al. - 1998 - Applying The Proactor Pattern To High-Performance .pdf:application/pdf;Citeseer - Snapshot:/home/vililipo/Zotero/storage/LJS9NUTX/summary.html:text/html}
}


@article{sinha_client-server_1992,
 author = {Sinha, Alok},
 title = {Client-server Computing},
 journal = {Commun. ACM},
 issue_date = {July 1992},
 volume = {35},
 number = {7},
 month = jul,
 year = {1992},
 issn = {0001-0782},
 pages = {77--98},
 numpages = {22},
 doi = {10.1145/129902.129908},
 acmid = {129908},
 }

@incollection{schmidt_reactor:_1995,
 author = {Schmidt, Douglas C.},
 chapter = {Reactor: An Object Behavioral Pattern for Concurrent Event Demultiplexing and Event Handler Dispatching},
 booktitle = {Pattern Languages of Program Design},
 editor = {Coplien, James O. and Schmidt, Douglas C.},
 year = {1995},
 isbn = {0-201-60734-4},
 pages = {529--545},
 numpages = {17},
 acmid = {218705},
 publisher = {ACM Press/Addison-Wesley Publishing Co.},
 address = {New York, NY, USA},
} 



@manual{libuv_design_2019,
	title = {Design overview — libuv documentation},
	url = {http://docs.libuv.org/en/v1.x/design.html},
	urldate = {2019-03-28},
	author = {libuv},
	file = {Design overview — libuv documentation:/home/vililipo/Zotero/storage/5J8RL67K/design.html:text/html}
}


@article{ling_analysis_2000,
	title = {Analysis of optimal thread pool size},
	volume = {34},
	issn = {01635980},
	doi = {10.1145/346152.346320},
	abstract = {The success of e-commerce, messaging middleware, and other lnternet-based applications depends in part on the ability of network servers to respond in a timely and reliable manner to simultaneous service requests. Multithreaded systems, due to their efficient use of system resources and the popularity of shared-memory multi-processor architectures, have become the server implementation of choice. However, creating and destroying a thread is far from free, requiring run-time memory allocation and deallocation. These overheads become especially onerous during periods of high load and can be a major factor behind system slowdowns. A thread-pool architecture addresses this problem by prespawning and then managing a pool of threads. Threads in the pool are reused, so that thread creation and destruction overheads are incurred only once per thread, and not once per request. However, efficient thread management for a given system load highly depends on the thread pool size, which is currently determined heuristically. In this paper, we characterize several system resource costs associated with thread pool size. If the thread pool is too large, and threads go unused, then processing and memory resources are wasted maintaining the thread pool. If the thread pool is too small, then additional threads must be created and destroyed on the fly to handle new requests. We analytically determine the optimal thread pool size to maximize the expected gain of using a thread.},
	number = {2},
	urldate = {2019-04-03},
	journal = {ACM SIGOPS Operating Systems Review},
	author = {Ling, Yibei and Mullen, Tracy and Lin, Xiaola},
	month = apr,
	year = {2000},
	pages = {42--55},
	file = {Ling et al. - 2000 - Analysis of optimal thread pool size.pdf:/home/vililipo/Zotero/storage/HYG48C4U/Ling et al. - 2000 - Analysis of optimal thread pool size.pdf:application/pdf}
}


@inbook{stallings_operating_2018,
	edition = {Global edition 9.},
	title = {Operating systems : internals and design principles},
	shorttitle = {Operating systems},
	publisher = {Pearson},
	author = {Stallings, William},
	year = {2018},
    pages = "177-331",
	file = {Operating systems | Helka-kirjastot | Helka:/home/vili/Zotero/storage/2JMW3HRL/helka.html:text/html}
}

@article{Berners-Lee_1994,
	author = {Berners-Lee,T.  and Dimitroyannis,Dimitri  and Mallinckrodt,A. John  and McKay,Susan },
	title = {World Wide Web},
	journal = {Computers in Physics},
	volume = {8},
	number = {3},
	pages = {298-299},
	year = {1994},
	doi = {10.1063/1.4823300},
}

@inproceedings{hu_measuring_1997,
	title = {Measuring the impact of event dispatching and concurrency models on {Web} server performance over high-speed networks},
	volume = {3},
	doi = {10.1109/GLOCOM.1997.644610},
	abstract = {Provides two contributions to the study of high-performance Web servers. First, it outlines the optimizations necessary to build efficient and scalable Web servers and illustrates how we've applied some of these optimizations to create JAWS. JAWS is a high-performance Web server that is explicitly designed to alleviate overheads incurred by existing Web servers on high-speed networks. It consistently outperforms existing Web servers (such as Apache, Java Server, PHTTPD, Zeus, and Netscape Enterprise) over 155 Mbps ATM networks on UNIX platforms. Second, this paper describes how we have customized JAWS to leverage advanced features of Windows NT for multiprocessor hardware over ATM. The Windows NT features used in JAWS include asynchronous mechanisms for connection establishment and data transfer. Our previous benchmarking studies demonstrate that once the overhead of disk I/O is reduced to a negligible constant factor, the primary determinants of Web server performance are the concurrency and event dispatching strategies. Our performance results over a /spl sim/155 Mbps ATM link indicate that certain Windows NT asynchronous I/O mechanisms (i.e. TransmitFile) provide superior performance for large file transfers compared with conventional synchronous multi-threaded servers. On the other hand, synchronous event dispatching performed better for files less than 50 kbytes. Thus, to provide optimal performance, Web servers should be adaptive, choosing to use different mechanisms to handle requests for large files, while using alternative I/O mechanisms for requests for small files.},
	booktitle = {{GLOBECOM} 97. {IEEE} {Global} {Telecommunications} {Conference}. {Conference} {Record}},
	author = {Hu, James C. and Pyarali, Irfan and Schmidt, Douglas C.},
	month = nov,
	year = {1997},
	keywords = {155 Mbit/s, asynchronous I/O mechanism, asynchronous mechanisms, asynchronous transfer mode, Asynchronous transfer mode, ATM networks, Computer science, concurrency models, Concurrent computing, connection establishment, data transfer, disk I/O, Dispatching, event dispatching, file servers, File servers, file transfers, Hardware, high-performance Web server, high-speed networks, High-speed networks, HTML, Internet, JAWS, multiprocessing programs, multiprocessor hardware, Network servers, optimisation, optimization, performance results, synchronous event dispatching, TransmitFile, UNIX platforms, Web server, Web server performance, Windows NT, World Wide Web},
	pages = {1924--1931 vol.3},
	file = {IEEE Xplore Abstract Record:/home/vililipo/Zotero/storage/YEQ8ESQU/644610.html:text/html;IEEE Xplore Full Text PDF:/home/vililipo/Zotero/storage/FQUNBP98/Hu et al. - 1997 - Measuring the impact of event dispatching and conc.pdf:application/pdf}
}

@article{welsh_seda_2001,
 author = {Welsh, Matt and Culler, David and Brewer, Eric},
 title = {SEDA: An Architecture for Well-conditioned, Scalable Internet Services},
 journal = {SIGOPS Oper. Syst. Rev.},
 issue_date = {Dec. 2001},
 volume = {35},
 number = {5},
 month = oct,
 year = {2001},
 issn = {0163-5980},
 pages = {230--243},
 numpages = {14},
 doi = {10.1145/502059.502057},
 acmid = {502057},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@inproceedings{voras_characteristics_2009,
	title = {Characteristics of multithreading models for high-performance {IO} driven network applications},
	doi = {10.1109/AFRCON.2009.5308411},
	abstract = {In a technological landscape that is quickly moving toward dense multi-CPU and multi-core computer systems, where using multithreading is an increasingly popular application design decision, it is important to choose a proper model for distributing tasks across multiple threads that will result in the best efficiency for the application and the system as a whole. The work described in this paper creates, implements and evaluates various models of distributing tasks to CPU threads and investigates their characteristics for use in modern high-performance network servers. The results presented here comprise a roadmap of models for building multithreaded server applications for modern server hardware and Unix-like operating systems.},
	booktitle = {{AFRICON} 2009},
	author = {Voras, I. and Zagar, M.},
	month = sep,
	year = {2009},
	keywords = {Application software, Buildings, Central Processing Unit, Computer architecture, concurrency control, data structures, Databases, Hardware, high-performance network servers, high-performance server software, IO driven network applications, multi CPU computer systems, multi-threading, multicore computer systems, multiprocessing, Multitasking, multithreading, Multithreading, multithreading models, network servers, Network servers, Payloads, processor scheduling, server hardware, SMP, threading models, Unix, Unix-like operating systems, Yarn},
	pages = {1--6},
	file = {IEEE Xplore Abstract Record:/home/vililipo/Zotero/storage/VMKNJX4E/5308411.html:text/html;IEEE Xplore Full Text PDF:/home/vililipo/Zotero/storage/ZACUM5P9/Voras and Zagar - 2009 - Characteristics of multithreading models for high-.pdf:application/pdf}
}



@manual{man_epoll,
	title = {epoll(7) - {Linux} manual page},
    author = { {Free Software Foundation} },
	url = {http://man7.org/linux/man-pages/man7/epoll.7.html},
    urldate = {2019-5-13},
	file = {epoll(7) - Linux manual page:/home/vili/Zotero/storage/UKWBV6TM/epoll.7.html:text/html}
}

@manual{noauthor_cluster_nodate,
	title = {Cluster {\textbar} {Node}.js v12.2.0 {Documentation}},
	url = {https://nodejs.org/api/cluster.html}, 
	urldate = {2019-05-13},
	file = {Cluster | Node.js v12.2.0 Documentation:/home/vili/Zotero/storage/D24QMY2S/cluster.html:text/html}
}

@inproceedings{harji_comparing_2012,
	address = {Haifa, Israel},
	title = {Comparing high-performance multi-core web-server architectures},
	isbn = {978-1-4503-1448-0},
	doi = {10.1145/2367589.2367591},
	abstract = {In this paper, we study how web-server architecture and implementation affect performance when trying to obtain high throughput on a 4-core system servicing static content. We focus on static content as a growing numbers of servers are dedicated to workloads comprised of songs, photos, software, and videos chunked for HTTP downloads. Two representative static-content workloads are used: one serviced entirely from the ﬁle-system cache and the other requires signiﬁcant disk I/O. We focus on 4-core systems as: 1) it is a widely used conﬁgurations in data-centers and cloud services, 2) recent studies show large SMP systems may operate more efﬁciently when subdivided into smaller subsystems, 3) understanding performance with a smaller number of cores is essential before scaling to a larger number of cores, 4) and 4-cores may be sufﬁcient for many web servers. Two high-performance web-servers, with event-driven (µserver) and pipelined (WatPipe) architectures, are developed and tested for a multi-core environment. By carefully implementing and tuning the two web-servers, both achieve performance comparable to running independent copies of the server on each processor (N-copy). The new web-servers achieve high throughput (4,000–6,000 Mbps) with 40,000 to 70,000 connects/second; performance in all cases is better than nginx, lighttpd, and Apache. We conclude that implementation and tuning of web servers is perhaps more important than server architecture. We also ﬁnd it is better to use blocking rather than non-blocking calls to sendﬁle, when the requested ﬁles do not all ﬁt in the ﬁle-system cache.},
	booktitle = {Proceedings of the 5th {Annual} {International} {Systems} and {Storage} {Conference} on - {SYSTOR} '12},
	publisher = {ACM Press},
	author = {Harji, Ashif S. and Buhr, Peter A. and Brecht, Tim},
	year = {2012},
	pages = {1--12},
	file = {Harji et al. - 2012 - Comparing high-performance multi-core web-server a.pdf:/home/vili/Zotero/storage/BANCJTRJ/Harji et al. - 2012 - Comparing high-performance multi-core web-server a.pdf:application/pdf}
}

@misc{leach_hypertext,
	title = {Hypertext {Transfer} {Protocol} -- {HTTP}/1.1},
	url = {https://tools.ietf.org/html/rfc2616},
	urldate = {2019-05-13},
	author = {Leach, Paul J. and Berners-Lee, Tim and Mogul, Jeffrey C. and Masinter, Larry and Fielding, Roy T. and Gettys, James},
	file = {Snapshot:/home/vili/Zotero/storage/6LWUHJZF/rfc2616.html:text/html}
}

@article{battle_bridging_2008,
	series = {Semantic {Web} and {Web} 2.0},
	title = {Bridging the semantic {Web} and {Web} 2.0 with {Representational} {State} {Transfer} ({REST})},
	volume = {6},
	issn = {1570-8268},
	doi = {10.1016/j.websem.2007.11.002},
	abstract = {Semantic Web technologies must integrate with Web 2.0 services for both to leverage each others strengths. We argue that the REST-based design methodologies [R.T. Fielding, R.N. Taylor, Principled design of the modern web architecture, ACM Trans. Internet Technol. (TOIT) 2 (2) (2002) 115–150] of the web present the ideal mechanism through which to align the publication of semantic data with the existing web architecture. We present the design and implementation of two solutions that combine REST-based design and RDF [D. Beckett (Ed.), RDF/XML Syntax Specification (Revised), W3C Recommendation, February 10, 2004] data access: one solution for integrating existing web services and one server-side solution for creating RDF REST services. Both of these solutions enable SPARQL [E. Prud’hommeaux, A. Seaborne (Eds.), SPARQL Query Language for RDF, W3C Working Draft, March 26, 2007] to be a unifying data access layer for aligning the Semantic Web and Web 2.0.},
	number = {1},
	journal = {Journal of Web Semantics},
	author = {Battle, Robert and Benson, Edward},
	month = feb,
	year = {2008},
    publisher = {Elsevier},
	keywords = {Representational State Transfer, Semantic Web, Web 2.0, Web Services},
	pages = {61--69},
	file = {ScienceDirect Snapshot:/home/vili/Zotero/storage/P5ZGC8BY/S1570826807000510.html:text/html}
}

@techreport{pyarali_proactor_1997,
	title = {{Proactor}: An {Object} {Behavioral} {Pattern} for {Demultiplexing} and {Dispatching} {Handlers} for {Asynchronous} {Events}},
	abstract = {Modern operating systems provide multiple mechanisms for developing concurrent applications. Synchronous multithreading is a popular mechanism for developing applications that perform multiple operations simultaneously. However, threads often have high performance overhead and require deep knowledge of synchronization patterns and principles. Therefore, an increasing number of operating systems support asynchronous mechanisms that provide the beneﬁts of concurrency while alleviating much of the overhead and complexity of multi-threading.},
  institution = {Deparment of Computer Science Washington University St. Louis},
	author = {Pyarali, Irfan and Harrison, Tim and Schmidt, Douglas C and Jordan, Thomas D},
	month = sep,
	year = {1997},
	file = {Pyarali et al. - An Object Behavioral Pattern for Demultiplexing an.pdf:/home/vililipo/Zotero/storage/IDWQA3GY/Pyarali et al. - An Object Behavioral Pattern for Demultiplexing an.pdf:application/pdf}
}
