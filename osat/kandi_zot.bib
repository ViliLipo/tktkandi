
@inproceedings{gallaba_dont_2015,
	title = {Don't {Call} {Us}, {We}'ll {Call} {You}: {Characterizing} {Callbacks} in {Javascript}},
	shorttitle = {Don't {Call} {Us}, {We}'ll {Call} {You}},
	doi = {10.1109/ESEM.2015.7321196},
	abstract = {JavaScript is a popular language for developing web applications and is increasingly used for both client-side and server-side application logic. The JavaScript runtime is inherently event-driven and callbacks are a key language feature. Unfortunately, callbacks induce a non-linear control flow and can be deferred to execute asynchronously, declared anonymously, and may be nested to arbitrary levels. All of these features make callbacks difficult to understand and maintain. We perform an empirical study to characterize JavaScript callback usage across a representative corpus of 138 JavaScript programs, with over 5 million lines of JavaScript code. We find that on average, every 10th function definition takes a callback argument, and that over 43\% of all callback-accepting function callsites are anonymous. Furthermore, the majority of callbacks are nested, more than half of all callbacks are asynchronous, and asynchronous callbacks, on average, appear more frequently in client-side code (72\%) than server-side (55\%). We also study three well-known solutions designed to help with the complexities associated with callbacks, including the error-first callback convention, Async.js library, and Promises. Our results inform the design of future JavaScript analysis and code comprehension tools.},
	booktitle = {2015 {ACM}/{IEEE} {International} {Symposium} on {Empirical} {Software} {Engineering} and {Measurement} ({ESEM})},
	author = {Gallaba, K. and Mesbah, A. and Beschastnikh, I.},
	month = oct,
	year = {2015},
	keywords = {Async.js library, Best practices, Browsers, callback argument, callback-accepting function, client-side application logic, code comprehension tool, Complexity theory, error-first callback convention, Games, Java, JavaScript analysis, JavaScript callback usage, JavaScript code, JavaScript language, JavaScript runtime feature, Libraries, program diagnostics, Protocols, Reactive power, server-side application logic, Web applications},
	pages = {1--10},
	file = {IEEE Xplore Abstract Record:/home/vili/Zotero/storage/EK8VUP6V/7321196.html:text/html;IEEE Xplore Full Text PDF:/home/vili/Zotero/storage/3BNKID4H/Gallaba et al. - 2015 - Don't Call Us, We'll Call You Characterizing Call.pdf:application/pdf}
}

@inproceedings{davis_case_2017,
	address = {New York, NY, USA},
	series = {{EuroSec}'17},
	title = {The {Case} of the {Poisoned} {Event} {Handler}: {Weaknesses} in the {Node}.{Js} {Event}-{Driven} {Architecture}},
	isbn = {978-1-4503-4935-2},
	shorttitle = {The {Case} of the {Poisoned} {Event} {Handler}},
	url = {http://doi.acm.org/10.1145/3065913.3065916},
	doi = {10.1145/3065913.3065916},
	abstract = {Node.js has seen rapid adoption in industry and the open-source community. Unfortunately, its event-driven architecture exposes Node.js applications to Event Handler-Poisoning denial of service attacks. Our evaluation of the state of practice in Node.js--- combining a study of 353 publicly reported security vulnerabilities and a survey of 151 representative npm modules --- demonstrates that the community is not equipped to combat this class of attack. We recommend several changes to the state of practice and propose both programming language and runtime approaches to defend against Event Handler-Poisoning attacks.},
	urldate = {2019-02-14},
	booktitle = {Proceedings of the 10th {European} {Workshop} on {Systems} {Security}},
	publisher = {ACM},
	author = {Davis, James and Kildow, Gregor and Lee, Dongyoon},
	year = {2017},
	note = {event-place: Belgrade, Serbia},
	keywords = {Denial of service, Event-driven architecture, Node.js, ReDoS},
	pages = {8:1--8:6},
	annote = {Tietoturva kohtainen, mutta lähteet arvokkaat myös minulle.},
	file = {ACM Full Text PDF:/home/vili/Zotero/storage/DX3958A8/Davis et al. - 2017 - The Case of the Poisoned Event Handler Weaknesses.pdf:application/pdf}
}

@inproceedings{pai_flash:_1999,
	title = {Flash: {An} {Efficient} and {Portable} {Web} {Server}},
	abstract = {This paper presents the design of a new Web server architecture called the asymmetric multi-process eventdriven (AMPED) architecture, and evaluates the performance of an implementation of this architecture, the Flash Web server. The Flash Web server combines the high performance of single-process event-driven servers on cached workloads with the performance of multiprocess and multi-threaded servers on disk-bound workloads. Furthermore, the Flash Web server is easily portable since it achieves these results using facilities available in all modern operating systems.},
	language = {en},
	booktitle = {Usenix Annual Technical conference 1999},
	author = {Pai, Vivek S and Druschel, Peter and Zwaenepoel, Willy},
	year = {1999},
	file = {Pai et al. - Flash An Efficient and Portable Web Server.pdf:/home/vililipo/Zotero/storage/HPGGC7AP/Pai et al. - Flash An Efficient and Portable Web Server.pdf:application/pdf}
}
@inproceedings{madsen_static_2015,
	address = {New York, NY, USA},
	series = {{OOPSLA} 2015},
	title = {Static {Analysis} of {Event}-driven {Node}.{Js} {JavaScript} {Applications}},
	isbn = {978-1-4503-3689-5},
	url = {http://doi.acm.org/10.1145/2814270.2814272},
	doi = {10.1145/2814270.2814272},
	abstract = {Many JavaScript programs are written in an event-driven style. In particular, in server-side Node.js applications, operations involving sockets, streams, and files are typically performed in an asynchronous manner, where the execution of listeners is triggered by events. Several types of programming errors are specific to such event-based programs (e.g., unhandled events, and listeners that are registered too late). We present the event-based call graph, a program representation that can be used to detect bugs related to event handling. We have designed and implemented three analyses for constructing event-based call graphs. Our results show that these analyses are capable of detecting problems reported on StackOverflow. Moreover, we show that the number of false positives reported by the analysis on a suite of small Node.js applications is manageable.},
	urldate = {2019-02-21},
	booktitle = {Proceedings of the 2015 {ACM} {SIGPLAN} {International} {Conference} on {Object}-{Oriented} {Programming}, {Systems}, {Languages}, and {Applications}},
	publisher = {ACM},
	author = {Madsen, Magnus and Tip, Frank and Lhoták, Ondřej},
	year = {2015},
	note = {event-place: Pittsburgh, PA, USA},
	keywords = {event-based systems, JavaScript, static analysis},
	pages = {505--519},
	file = {ACM Full Text PDF:/home/vili/Zotero/storage/JFUW953C/Madsen et al. - 2015 - Static Analysis of Event-driven Node.Js JavaScript.pdf:application/pdf}
}

@article{praphamontripong_analytical_2007,
	title = {An {Analytical} {Approach} to {Performance} {Analysis} of an {Asynchronous} {Web} {Server}},
	volume = {83},
	issn = {0037-5497},
	url = {https://doi.org/10.1177/0037549707080891},
	doi = {10.1177/0037549707080891},
	abstract = {Concurrency can be implemented in a Web server using synchronous or asynchronous mechanisms provided by the underlying operating system. Compared to the synchronous mechanisms, asynchronous mechanisms are attractive because they provide the benefit of concurrency while alleviating much of the overhead and compleXity of multi-threading. The Proactor pattern in middleware, which encapsulates the asynchronous mechanisms provided by the operating system, can be used to implement a high performance Web server. The performance eXpectations imposed on a Web server make it necessary to analyze its performance prior to deployment. While the performance of a server can be measured after implementation, design-time performance analysis, conducted early in the life cycle, can enable informed configuration and provisioning choices. A model-based approach can be used for such design-time performance analysis. In this paper we present a performance model of the architecture of an asynchronous Web server which uses the Proactor pattern. We discuss the implementation of the performance model using the Stochastic Reward Net (SRN) modeling paradigm. A model decomposition strategy along with its SRN implementation to facilitate the application of the model to practical Web servers is then described. We demonstrate the use of the model to guide key provisioning and configuration decisions with several eXamples.},
	language = {en},
	number = {8},
	urldate = {2019-02-21},
	journal = {SIMULATION},
	author = {Praphamontripong, U. and Gokhale, S. and Gokhale, Aniruddha and Gray, Jeff},
	month = aug,
	year = {2007},
	pages = {571--586},
	file = {SAGE PDF Full Text:/home/vili/Zotero/storage/AUWYUBIV/Praphamontripong et al. - 2007 - An Analytical Approach to Performance Analysis of .pdf:application/pdf}
}

@inproceedings{gokhale_performance_2006,
	title = {Performance {Analysis} of the {Reactor} {Pattern} in {Network} {Services}},
	doi = {10.1109/IPDPS.2006.1639639},
	abstract = {The growing reliance on services provided by software applications places a high premium on the reliable and efficient operation of these applications. A number of these applications follow the event-driven software architecture style since this style fosters evolvability by separating event handling from event demultiplexing and dispatching functionality. The event demultiplexing capability, which appears repeatedly across a class of event-driven applications, can be codified into a reusable pattern, such as the reactor pattern. In order to enable performance analysis of event-driven applications at design time, a model is needed that represents the event demultiplexing and handling functionality that lies at the heart of these applications. In this paper, we present a model of the reactor pattern based on the well-established stochastic reward net (SRN) modeling paradigm. We discuss how the model can be used to obtain several performance measures such as the throughput, loss probability and upper and lower bounds on the response time. We illustrate how the model can be used to obtain the performance metrics of a virtual private network (VPN) service provided by a virtual router (VR). We validate the estimates of the performance measures obtained from the SRN model using simulation},
	booktitle = {Proceedings 20th {IEEE} {International} {Parallel} {Distributed} {Processing} {Symposium}},
	author = {Gokhale, S. and Gokhale, A. and Gray, J. and Vandal, P. and Praphamontripong, U.},
	month = apr,
	year = {2006},
	keywords = {Application software, Demultiplexing, Dispatching, dispatching functionality, event demultiplexing, event handling, event-driven software architecture, Heart, Inductors, middleware, middleware performance analysis, network services, object-oriented programming, Performance analysis, Performance loss, reactor pattern, reusable pattern, Software architecture, software performance evaluation, Stochastic processes, stochastic reward net modeling, virtual private network service, Virtual private networks, virtual router},
	pages = {1--9},
	annote = {Vaikuttaa erittäin lupaavalta.
 },
	file = {IEEE Xplore Abstract Record:/home/vili/Zotero/storage/XVDN35D2/1639639.html:text/html;IEEE Xplore Full Text PDF:/home/vili/Zotero/storage/Q7VHSN3V/Gokhale et al. - 2006 - Performance Analysis of the Reactor Pattern in Net.pdf:application/pdf}
}


@inproceedings{hu_applying_1998,
	title = {Applying {The} {Proactor} {Pattern} {To} {High}-{Performance} {Web} {Servers}},
	abstract = {Modern operating systems provide multiple concurrency mechanisms to develop high-performance Web servers. Synchronous multi-threading is a popular mechanism for developing Web servers that must perform multiple operations simultaneously to meet their performance requirements. In addition, an increasing number of operating systems support asynchronous mechanisms that provide the benefits of concurrency, while alleviating much of the performance overhead of synchronous multi-threading. This paper provides two contributions to the study of high-performance Web servers. First, it examines how synchronous and asynchronous event dispatching mechanisms impact the design and performance of JAWS, which is our high-performance Web server framework. The results reveal significant performance improvements when a proactive concurrency model is used to combine lightweight concurrency with asynchronous event dispatching. In general, however, the complexity of the proactive concurrency model makes it ...},
	booktitle = {In {Proceedings} of the 10th {International} {Conference} on {Parallel} and {Distributed} {Computing} and {Systems}},
	author = {Hu, James and Pyarali, Irfan and Schmidt, Douglas C.},
	year = {1998},
	file = {Citeseer - Full Text PDF:/home/vililipo/Zotero/storage/59DS4828/Hu et al. - 1998 - Applying The Proactor Pattern To High-Performance .pdf:application/pdf;Citeseer - Snapshot:/home/vililipo/Zotero/storage/LJS9NUTX/summary.html:text/html}
}


@incollection{easton_developing_2004,
	address = {Berkeley, CA},
	title = {Developing {Distributed} {Applications}},
	isbn = {978-1-4302-5365-5 978-1-4302-0746-7},
	url = {http://link.springer.com/10.1007/978-1-4302-0746-7_6},
	abstract = {The ADAPTIVE Service eXecutive (ASX) is a highly modular and extensible object-oriented framework that simpliﬁes the development and conﬁguration of distributed applications on shared memory multi-processor platforms. This paper describes the structure and functionality of the ASX framework’s object-oriented architecture. In addition, the paper presents the results of performance experiments conducted using ASX-based implementations of connection-oriented and connectionless protocols from the TCP/IP protocol family. These experiments measure the performance impact of alternative methods for parallelizing communication protocol stacks. Throughout the paper, examples are presented to indicate how the use of object-oriented techniques facilitate application extensibility, component reuse, and performance enhancement.},
	language = {en},
	urldate = {2019-03-05},
	booktitle = {Cross-{Platform} .{NET} {Development}: {Using} {Mono}, {Portable}.{NET}, and {Microsoft} .{NET}},
	publisher = {Apress},
	author = {Easton, M. J. and King, Jason},
	collaborator = {Easton, M. J. and King, Jason},
	year = {2004},
	doi = {10.1007/978-1-4302-0746-7_6},
	pages = {201--266},
	file = {Easton and King - 2004 - Developing Distributed Applications.pdf:/home/vililipo/Zotero/storage/BM2QUBGB/Easton and King - 2004 - Developing Distributed Applications.pdf:application/pdf}
}

@article{sinha_client-server_1992,
	title = {Client-server computing},
	volume = {35},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=129902.129908},
	doi = {10.1145/129902.129908},
	language = {en},
	number = {7},
	urldate = {2019-03-28},
	journal = {Communications of the ACM},
	author = {Sinha, Alok},
	month = jul,
	year = {1992},
	pages = {77--98},
	file = {Sinha - 1992 - Client-server computing.pdf:/home/vililipo/Zotero/storage/F3PT88VM/Sinha - 1992 - Client-server computing.pdf:application/pdf}
}


@article{schmidt_reactor:_1995,
	title = {Reactor: {An} {Object} {Behavioral} {Pattern} for {Concurrent} {Event} {Demultiplexing} and {Dispatching}},
	shorttitle = {Reactor},
	abstract = {Factory design patterns [9]), and advanced operating system mechanisms (such as explicit dynamic linking and multi-threading [10]).  9 Sample Code  The following code illustrates an example of the Reactor object behavioral pattern. The example implements a portion of the logging server described in Section 2. This example also illustrates the use of an object creational pattern called the Accepter (described in [7]). The Accepter pattern decouples the act of establishing a connection from the service(s) provided once a connection is established. This pattern is useful for simplifying the development of connection-oriented network services (such as file transfer, remote login, distributed logging, and video-on-demand). The Accepter pattern enables the application-specific portion of a service to be modified independently of the mechanism used to establish the connection.  The code shown below implements the ClientAccepter class. This class performs the steps necessary to accept connecti...},
	author = {Schmidt, Douglas C.},
	year = {1995},
	file = {Citeseer - Full Text PDF:/home/vililipo/Zotero/storage/QRI64KF2/Schmidt - 1995 - Reactor An Object Behavioral Pattern for Concurre.pdf:application/pdf;Citeseer - Snapshot:/home/vililipo/Zotero/storage/7PD2GE5V/summary.html:text/html}
}

@misc{libuv_design_2019,
	title = {Design overview — libuv documentation},
	url = {http://docs.libuv.org/en/v1.x/design.html},
	urldate = {2019-03-28},
	author = {libuv},
	file = {Design overview — libuv documentation:/home/vililipo/Zotero/storage/5J8RL67K/design.html:text/html}
}


@article{ling_analysis_2000,
	title = {Analysis of optimal thread pool size},
	volume = {34},
	issn = {01635980},
	url = {http://portal.acm.org/citation.cfm?doid=346152.346320},
	doi = {10.1145/346152.346320},
	abstract = {The success of e-commerce, messaging middleware, and other lnternet-based applications depends in part on the ability of network servers to respond in a timely and reliable manner to simultaneous service requests. Multithreaded systems, due to their efficient use of system resources and the popularity of shared-memory multi-processor architectures, have become the server implementation of choice. However, creating and destroying a thread is far from free, requiring run-time memory allocation and deallocation. These overheads become especially onerous during periods of high load and can be a major factor behind system slowdowns. A thread-pool architecture addresses this problem by prespawning and then managing a pool of threads. Threads in the pool are reused, so that thread creation and destruction overheads are incurred only once per thread, and not once per request. However, efficient thread management for a given system load highly depends on the thread pool size, which is currently determined heuristically. In this paper, we characterize several system resource costs associated with thread pool size. If the thread pool is too large, and threads go unused, then processing and memory resources are wasted maintaining the thread pool. If the thread pool is too small, then additional threads must be created and destroyed on the fly to handle new requests. We analytically determine the optimal thread pool size to maximize the expected gain of using a thread.},
	language = {en},
	number = {2},
	urldate = {2019-04-03},
	journal = {ACM SIGOPS Operating Systems Review},
	author = {Ling, Yibei and Mullen, Tracy and Lin, Xiaola},
	month = apr,
	year = {2000},
	pages = {42--55},
	file = {Ling et al. - 2000 - Analysis of optimal thread pool size.pdf:/home/vililipo/Zotero/storage/HYG48C4U/Ling et al. - 2000 - Analysis of optimal thread pool size.pdf:application/pdf}
}


@inproceedings{pyarali_proactor_1997,
	title = {Proactor - {An} {Object} {Behavioral} {Pattern} for {Demultiplexing} and {Dispatching} {Handlers} for {Asynchronous} {Events}},
	abstract = {Modern operating systems provide multiple mechanisms for developing concurrent applications. Synchronous multithreading is a popular mechanism for developing applications that perform multiple operations simultaneously. However, threads often have high performance overhead and require deep knowledge of synchronization patterns and principles. Therefore, an increasing number of operating systems support asynchronous mechanisms that provide the benefits of concurrency while alleviating much of the overhead and complexity of multi-threading. The Proactor pattern presented in this paper describes how to structure applications and systems that effectively utilize asynchronous mechanisms supported by operating systems. When an application invokes an asynchronous operation, the OS performs the operation on behalf of the application. This allows the application to have multiple operations running simultaneously without requiring the application to have a corresponding number of threads. Theref...},
	author = {Pyarali, Irfan and Harrison, Tim and Schmidt, Douglas C. and Jordan, Thomas D.},
	year = {1997},
	file = {Citeseer - Full Text PDF:/home/vili/Zotero/storage/ZF99HDCK/Pyarali et al. - 1997 - Proactor - An Object Behavioral Pattern for Demult.pdf:application/pdf;Citeseer - Snapshot:/home/vili/Zotero/storage/L9E3VUN8/summary.html:text/html}
}


@inbook{stallings_operating_2018,
	edition = {Ninth edition, Global edition},
	title = {Operating systems : internals and design principles},
	shorttitle = {Operating systems},
	publisher = {Pearson},
	author = {Stallings, William},
	year = {2018},
    pages = "177-331",
	file = {Operating systems | Helka-kirjastot | Helka:/home/vili/Zotero/storage/2JMW3HRL/helka.html:text/html}
}

@article{Berners-Lee_1994,
	author = {Berners-Lee,T.  and Dimitroyannis,Dimitri  and Mallinckrodt,A. John  and McKay,Susan },
	title = {World Wide Web},
	journal = {Computers in Physics},
	volume = {8},
	number = {3},
	pages = {298-299},
	year = {1994},
	doi = {10.1063/1.4823300},

	URL = {
        https://aip.scitation.org/doi/abs/10.1063/1.4823300

				},
				eprint = {
        https://aip.scitation.org/doi/pdf/10.1063/1.4823300

				}
}

@inproceedings{tatsubori_html_2009,
	address = {Madrid, Spain},
	title = {{HTML} templates that fly: a template engine approach to automated offloading from server to client},
	isbn = {978-1-60558-487-4},
	shorttitle = {{HTML} templates that fly},
	url = {http://portal.acm.org/citation.cfm?doid=1526709.1526837},
	doi = {10.1145/1526709.1526837},
	abstract = {Web applications often use HTML templates to separate the webpage presentation from its underlying business logic and objects. This is now the de facto standard programming model for Web application development. This paper proposes a novel implementation for existing server-side template engines, FlyingTemplate, for (a) reduced bandwidth consumption in Web application servers, and (b) oﬀ-loading HTML generation tasks to Web clients. Instead of producing a fully-generated HTML page, the proposed template engine produces a skeletal script which includes only the dynamic values of the template parameters and the bootstrap code that runs on a Web browser at the client side. It retrieves a client-side template engine and the payload templates separately. With the goals of eﬃciency, implementation transparency, security, and standards compliance in mind, we developed FlyingTemplate with two design principles: eﬀective browser cache usage, and reasonable compromises which restrict the template usage patterns and relax the security policies slightly but in a controllable way. This approach allows typical template-based Web applications to run eﬀectively with FlyingTemplate. As an experiment, we tested the SPECweb2005 banking application using FlyingTemplate without any other modiﬁcations and saw throughput improvements from 1.6x to 2.0x in its best mode. In addition, FlyingTemplate can enforce compliance with a simple security policy, thus addressing the security problems of client-server partitioning in the Web environment.},
	language = {en},
	urldate = {2019-04-09},
	booktitle = {Proceedings of the 18th international conference on {World} wide web - {WWW} '09},
	publisher = {ACM Press},
	author = {Tatsubori, Michiaki and Suzumura, Toyotaro},
	year = {2009},
	pages = {951},
	file = {Tatsubori and Suzumura - 2009 - HTML templates that fly a template engine approac.pdf:/home/vili/Zotero/storage/9NEJACQ3/Tatsubori and Suzumura - 2009 - HTML templates that fly a template engine approac.pdf:application/pdf}
}


@inproceedings{hu_measuring_1997,
	title = {Measuring the impact of event dispatching and concurrency models on {Web} server performance over high-speed networks},
	volume = {3},
	doi = {10.1109/GLOCOM.1997.644610},
	abstract = {Provides two contributions to the study of high-performance Web servers. First, it outlines the optimizations necessary to build efficient and scalable Web servers and illustrates how we've applied some of these optimizations to create JAWS. JAWS is a high-performance Web server that is explicitly designed to alleviate overheads incurred by existing Web servers on high-speed networks. It consistently outperforms existing Web servers (such as Apache, Java Server, PHTTPD, Zeus, and Netscape Enterprise) over 155 Mbps ATM networks on UNIX platforms. Second, this paper describes how we have customized JAWS to leverage advanced features of Windows NT for multiprocessor hardware over ATM. The Windows NT features used in JAWS include asynchronous mechanisms for connection establishment and data transfer. Our previous benchmarking studies demonstrate that once the overhead of disk I/O is reduced to a negligible constant factor, the primary determinants of Web server performance are the concurrency and event dispatching strategies. Our performance results over a /spl sim/155 Mbps ATM link indicate that certain Windows NT asynchronous I/O mechanisms (i.e. TransmitFile) provide superior performance for large file transfers compared with conventional synchronous multi-threaded servers. On the other hand, synchronous event dispatching performed better for files less than 50 kbytes. Thus, to provide optimal performance, Web servers should be adaptive, choosing to use different mechanisms to handle requests for large files, while using alternative I/O mechanisms for requests for small files.},
	booktitle = {{GLOBECOM} 97. {IEEE} {Global} {Telecommunications} {Conference}. {Conference} {Record}},
	author = {Hu, J. C. and Pyarali, I. and Schmidt, D. C.},
	month = nov,
	year = {1997},
	keywords = {155 Mbit/s, asynchronous I/O mechanism, asynchronous mechanisms, asynchronous transfer mode, Asynchronous transfer mode, ATM networks, Computer science, concurrency models, Concurrent computing, connection establishment, data transfer, disk I/O, Dispatching, event dispatching, file servers, File servers, file transfers, Hardware, high-performance Web server, high-speed networks, High-speed networks, HTML, Internet, JAWS, multiprocessing programs, multiprocessor hardware, Network servers, optimisation, optimization, performance results, synchronous event dispatching, TransmitFile, UNIX platforms, Web server, Web server performance, Windows NT, World Wide Web},
	pages = {1924--1931 vol.3},
	file = {IEEE Xplore Abstract Record:/home/vililipo/Zotero/storage/YEQ8ESQU/644610.html:text/html;IEEE Xplore Full Text PDF:/home/vililipo/Zotero/storage/FQUNBP98/Hu et al. - 1997 - Measuring the impact of event dispatching and conc.pdf:application/pdf}
}

@article{welsh_seda_2001,
 author = {Welsh, Matt and Culler, David and Brewer, Eric},
 title = {SEDA: An Architecture for Well-conditioned, Scalable Internet Services},
 journal = {SIGOPS Oper. Syst. Rev.},
 issue_date = {Dec. 2001},
 volume = {35},
 number = {5},
 month = oct,
 year = {2001},
 issn = {0163-5980},
 pages = {230--243},
 numpages = {14},
 url = {http://doi.acm.org/10.1145/502059.502057},
 doi = {10.1145/502059.502057},
 acmid = {502057},
 publisher = {ACM},
 address = {New York, NY, USA},
} 

@inproceedings{voras_characteristics_2009,
	title = {Characteristics of multithreading models for high-performance {IO} driven network applications},
	doi = {10.1109/AFRCON.2009.5308411},
	abstract = {In a technological landscape that is quickly moving toward dense multi-CPU and multi-core computer systems, where using multithreading is an increasingly popular application design decision, it is important to choose a proper model for distributing tasks across multiple threads that will result in the best efficiency for the application and the system as a whole. The work described in this paper creates, implements and evaluates various models of distributing tasks to CPU threads and investigates their characteristics for use in modern high-performance network servers. The results presented here comprise a roadmap of models for building multithreaded server applications for modern server hardware and Unix-like operating systems.},
	booktitle = {{AFRICON} 2009},
	author = {Voras, I. and Zagar, M.},
	month = sep,
	year = {2009},
	keywords = {Application software, Buildings, Central Processing Unit, Computer architecture, concurrency control, data structures, Databases, Hardware, high-performance network servers, high-performance server software, IO driven network applications, multi CPU computer systems, multi-threading, multicore computer systems, multiprocessing, Multitasking, multithreading, Multithreading, multithreading models, network servers, Network servers, Payloads, processor scheduling, server hardware, SMP, threading models, Unix, Unix-like operating systems, Yarn},
	pages = {1--6},
	file = {IEEE Xplore Abstract Record:/home/vililipo/Zotero/storage/VMKNJX4E/5308411.html:text/html;IEEE Xplore Full Text PDF:/home/vililipo/Zotero/storage/ZACUM5P9/Voras and Zagar - 2009 - Characteristics of multithreading models for high-.pdf:application/pdf}
}



@manual{man_epoll,
	title = {epoll(7) - {Linux} manual page},
    author = { Free Software Foundation },
	url = {http://man7.org/linux/man-pages/man7/epoll.7.html},
	urldate = {2019-04-27},
	file = {epoll(7) - Linux manual page:/home/vili/Zotero/storage/UKWBV6TM/epoll.7.html:text/html}
}

@misc{noauthor_cluster_nodate,
	title = {Cluster {\textbar} {Node}.js v12.2.0 {Documentation}},
	url = {https://nodejs.org/api/cluster.html#cluster_cluster},
	urldate = {2019-05-13},
	file = {Cluster | Node.js v12.2.0 Documentation:/home/vili/Zotero/storage/D24QMY2S/cluster.html:text/html}
}

@inproceedings{harji_comparing_2012,
	address = {Haifa, Israel},
	title = {Comparing high-performance multi-core web-server architectures},
	isbn = {978-1-4503-1448-0},
	url = {http://dl.acm.org/citation.cfm?doid=2367589.2367591},
	doi = {10.1145/2367589.2367591},
	abstract = {In this paper, we study how web-server architecture and implementation affect performance when trying to obtain high throughput on a 4-core system servicing static content. We focus on static content as a growing numbers of servers are dedicated to workloads comprised of songs, photos, software, and videos chunked for HTTP downloads. Two representative static-content workloads are used: one serviced entirely from the ﬁle-system cache and the other requires signiﬁcant disk I/O. We focus on 4-core systems as: 1) it is a widely used conﬁgurations in data-centers and cloud services, 2) recent studies show large SMP systems may operate more efﬁciently when subdivided into smaller subsystems, 3) understanding performance with a smaller number of cores is essential before scaling to a larger number of cores, 4) and 4-cores may be sufﬁcient for many web servers. Two high-performance web-servers, with event-driven (µserver) and pipelined (WatPipe) architectures, are developed and tested for a multi-core environment. By carefully implementing and tuning the two web-servers, both achieve performance comparable to running independent copies of the server on each processor (N-copy). The new web-servers achieve high throughput (4,000–6,000 Mbps) with 40,000 to 70,000 connects/second; performance in all cases is better than nginx, lighttpd, and Apache. We conclude that implementation and tuning of web servers is perhaps more important than server architecture. We also ﬁnd it is better to use blocking rather than non-blocking calls to sendﬁle, when the requested ﬁles do not all ﬁt in the ﬁle-system cache.},
	language = {en},
	urldate = {2019-05-13},
	booktitle = {Proceedings of the 5th {Annual} {International} {Systems} and {Storage} {Conference} on - {SYSTOR} '12},
	publisher = {ACM Press},
	author = {Harji, Ashif S. and Buhr, Peter A. and Brecht, Tim},
	year = {2012},
	pages = {1--12},
	file = {Harji et al. - 2012 - Comparing high-performance multi-core web-server a.pdf:/home/vili/Zotero/storage/BANCJTRJ/Harji et al. - 2012 - Comparing high-performance multi-core web-server a.pdf:application/pdf}
}

@misc{leach_hypertext,
	title = {Hypertext {Transfer} {Protocol} -- {HTTP}/1.1},
	url = {https://tools.ietf.org/html/rfc2616},
	language = {en},
	urldate = {2019-05-13},
	author = {Leach, Paul J. and Berners-Lee, Tim and Mogul, Jeffrey C. and Masinter, Larry and Fielding, Roy T. and Gettys, James},
	file = {Snapshot:/home/vili/Zotero/storage/6LWUHJZF/rfc2616.html:text/html}
}

@article{battle_bridging_2008,
	series = {Semantic {Web} and {Web} 2.0},
	title = {Bridging the semantic {Web} and {Web} 2.0 with {Representational} {State} {Transfer} ({REST})},
	volume = {6},
	issn = {1570-8268},
	url = {http://www.sciencedirect.com/science/article/pii/S1570826807000510},
	doi = {10.1016/j.websem.2007.11.002},
	abstract = {Semantic Web technologies must integrate with Web 2.0 services for both to leverage each others strengths. We argue that the REST-based design methodologies [R.T. Fielding, R.N. Taylor, Principled design of the modern web architecture, ACM Trans. Internet Technol. (TOIT) 2 (2) (2002) 115–150] of the web present the ideal mechanism through which to align the publication of semantic data with the existing web architecture. We present the design and implementation of two solutions that combine REST-based design and RDF [D. Beckett (Ed.), RDF/XML Syntax Specification (Revised), W3C Recommendation, February 10, 2004] data access: one solution for integrating existing web services and one server-side solution for creating RDF REST services. Both of these solutions enable SPARQL [E. Prud’hommeaux, A. Seaborne (Eds.), SPARQL Query Language for RDF, W3C Working Draft, March 26, 2007] to be a unifying data access layer for aligning the Semantic Web and Web 2.0.},
	number = {1},
	urldate = {2019-05-13},
	journal = {Journal of Web Semantics},
	author = {Battle, Robert and Benson, Edward},
	month = feb,
	year = {2008},
	keywords = {Representational State Transfer, Semantic Web, Web 2.0, Web Services},
	pages = {61--69},
	file = {ScienceDirect Snapshot:/home/vili/Zotero/storage/P5ZGC8BY/S1570826807000510.html:text/html}
}