\documentclass[12pt]{article}
\usepackage{cite}
\usepackage[finnish]{babel}
\usepackage{makeidx}

\makeindex

\title{Rinnakkaisuus modernissa verkkopalvelinsovelluksessa}
\author{Vili Lipo}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\index{Tiivistelma}
\section*{Tiivistelmä}
Tässä tutkielmassa vertaillaan verkkopalvelimien toteutusmalleja
ja niiden suorituskykyä. Verkkopalvelin on ohjelma, joka vastaa useiden asiakkaiden pyyntöihin
verkkosivuilla tai verkkosovelluksissa. Pyyntöihin vastaamiseen
voi liittyä laskentaa, tietokantaoperaatioita tai muita toimenpiteitä.

Vertailuun valittiin tapahtumaohjattu Reactor palvelinmalli, sekä säiereservimalli.
Reactor-malli on kasvattanut suosiotaan pitkään verkkosovelluskehityksessä.
Sitä vastaan vertailussa on säiereservimalli sillä siinä on
onnistuttu korjaamaan joitakin yksi-säie-yhteyttä-kohti-mallin ongelmia.
\section{Johdanto}
\section{Verkkopalvelinsovellus}
\subsection{Asiakas-palvelin malli}
Asiakas-palvelin mallissa
asiakasosa tarjoaa käyttäjälle käyttöliittymän sovellukseen. Palvelinosa taas
tarjoaa määritellyn rajapinnan
palveluita asiakasosalle verkkoyhteyden yli~\cite{sinha_client-server_1992}.
Tieto välittyy osien välillä pyyntöinä ja vastauksina ja näin palvelinosa ja asiakasosa
muodostavat löysästi yhdistetyn järjestelmän.

Asiakasosa siis yhdistää käyttöliittymässä tapahtuvat toimet palvelimen
rajapinnan pyynnöiksi. Se voi hyödyntää pyyntöjen tulosten tallentamista
muistiin. Näin tarvittavia pyyntöjä voidaan vähentää, jos sen tulos
on jo paikallisessa muistissa. Asiakasosa voi myös suorittaa
laskentaa tai muita toimenpiteitä paikallisesti~\cite{sinha_client-server_1992}.

Asiakasosat voivat olla työpöytäsovelluksia, jotka hyödyntävät käyttöjärjestelmän
ikkunointi-ja käyttöliittymäominaisuuksia~\cite{sinha_client-server_1992}.
Tämänkaltaisen asiakasohjelman toteuttamisessa voidaan käyttää mitä tahansa ohjelmointikieltä,
ja asiakasohjelman toiminnallisuutta voi laajentaa lähes rajatta.

Asiakasohjelma voi olla myös verkkosivu. 2000-luvun alussa
pelkkään staattiseen HTML-standardiin perustuvat verkkosivut pystyivät
tarjoamaan käyttöliittymiä esimerkiksi keskustelualustoille ja verkkokaupoille.
Näissä järjestelmissä valtaosa suorittamisesta on palvelimen vastuulla,
sillä sen pitää tiedonkäsittelemisen lisäksi kirjoittaa tieto
esitettävään HTML-muotoon käyttöliittymän näkymäksi~\cite{tatsubori_html_2009}. Palvelin
siis vastaa selaimen pyyntöön lähettämällä kokonaisen HTML-tiedoston.

Nykyisten selainten JavaScript suoritustuen ansiosta yhä
monimutkaisempia asiakassovelluksia voidaan toteuttaa
selaimella saavutettavilla verkkosovelluksina.
Nykyään palvelimen ja asiakkaan
välisessä tiedonvälityksessä on muodikasta käyttää REST-rajapintaa, jossa
tieto on rakenteisessa muodossa. Asiakasosa tämän jälkeen piirtää siitä
itsenäisesti käyttöliittymän näkymän. [lähde?]

Palvelin tarjoaa rajapinnan läpi palveluita asiakasohjelmille.
Palvelin ei itsenäisesti aloita yhteyttä mihinkään
asiakkaaseen vaan se odottaa niiden pyyntöjä.
Se pystyy palvelemaan useita asiakkaita, jopa
eri asiakasohjelmia, kunhan asiakasohjelmat noudattavat
palvelimen rajapintaa~\cite{sinha_client-server_1992}.

Palvelimen palvelut muodostavat järjestelmän keskeisen
sovelluslogiikan, jossa asiakaspyynnön parametreilla
suoritetaan toimintoja ja palvelin lähettää
tuloksen vastauksena~\cite{sinha_client-server_1992}.

Yleisesti palvelin vastaa järjestelmän turvallisuudesta sillä,
sen toiminnan vääristäminen on haastavampaa paha-aikeisille
toimijoille, kun taas asiakasosan toiminnan muuntelu, pyyntöjen
lähettäminen toisella ohjelmistolla on suoraviivaisempaa.

Asiakasohjelmaa ajetaan laitteella, joka ei ole verkkosovelluksen
ylläpitäjän hallussa. Paha-aikeiset toimijat voitat käyttää tätä hyväkseen
ja tarkkailla asiakasosan lähettämiä pyyntöjä tai sen
suorituskäyttäytymistä kuten resurssien käyttöä.
Tarkkailusta selvinneiden tietojen avulla on mahdollista
kiertää asiakasosaan toteutettuja suojauksia.

Palvelinsovelluksen toimintaa vääristääkseen 
paha-aikeisten toimijoiden tulisi päästä
käsiksi sitä suorittavan järjestelmän hallintatoimintoihin, tai
löytää haavoittuvuus sen rajapinnasta. Nämä hyökkäysvektorit
ovat huomattavasti kapeampia kuin sovelluksella jota
suoritetaan hyökkääjien omalla laitteistolla.
% etsi jokin tietoturvan perusteos
Palvelin vastaa myös tunnistautumisesta sekä käyttöoikeuksien hallinnasta.
Monen palvelun toteuttamisen kannalta on kriittistä, että
tiedon käyttöoikeuksia voidaan rajata käyttäjän tunnistautumisen perusteella.

Yksinkertainen esimerkki asiakas-palvelin mallista on tietokantapalvelin,
jossa tietokannan tiedot on tallennettu palvelimelle, josta voidaan
asiakasohjelmalla tehdä verkon yli tietokantakyselyitä.

Verkkopalvelin on palvelin, jonka tehtävä on vastata Internetin
selaamiseen liittyviin pyyntöihin eli lähettämään tietyn HTTP-pyynnön
perusteella oikea HTML-tiedosto, tekstimuotoinen datatiedosto~\cite{Berners-Lee_1994}
,tai kuvatiedosto.
\subsection{Rinnakkaisuus palvelinsovelluksessa}

Rinnakkaisuudella tarkoitetaan tietojenkäsittelytieteessä useiden
eri operaatioiden suorittamista järjestelmässä samaan aikaan.
Nykyisissä palvelintietokoneissa on kymmeniä suorittimia ja niiden tehokkaaseen
hyödyntämiseen tarvitaan rinnakkaisuuden hallintaa.

On täysin tehtäväkohtaista
kuinka hyvin rinnakkaisuuden tavoitteet voidaan saavuttaa.
Tähän vaikuttaa kuinka suuri osa tehtävästä on olemukseltaan peräkkäistä.
Peräkkäiset osat ovat sellaisia, jossa ohjelman vaiheet ovat täysin
riippuvaisia toisistaan ja seuraavaan vaiheeseen ei voida mennä ennen edellisen
valmistumista. Jos suuri osa ohjelmasta on peräkkäistä, ei rinnakaistamalla
saada hyötyä. Tällaisessa tapauksessa rinnakkaisuuden hallinnasta aiheutuvat
rasitteet saattavat jopa heikentää suorituskykyä~\cite{stallings_operating_2018}.

Riippumatta tehtävästä rinnakkaisuuden saavuttaminen on vaikeaa,
sillä se tuo ohjelmoijalle uusia haasteita, jotka eroavat tavallisesta
ohjelmoinnista. Ohjelmointivirheen riski on rinnakkaisissa osissa hyvin suuri,
koska ohjelman oikeellisuuden varmistaminen kaikissa mahdollisissa
suoritusjärjestyksissä on erittäin työlästä.
Keskeisiä ongelmia, joita rinnakkaisuus tuo ohjelmointiin on eri vaiheiden
synkronointi, tietorakenteiden suojaaminen ja lukkiutumisen hallinta.

Verkkopalvelinsovelluksessa yksi asiakkaan pyyntö http-protokollan välityksellä
muodostaa mielekkään kokonaisuuden.
Järjestelmässä on toivottavaa, että pyyntöjä voitaisiin suorittaa
rinnakkain kaikilla järjestelmässä olevilla suorittimilla, tai muuten 
saavuttaa korkea resurssien käyttöaste.
Näin ohjelmistojärjestelmä skaalautuu saatavilla oleviin resursseihin
mielekkäällä tasolla. Käsiteltävät pyynnöt eivät yleisesti ole riippuvaisia
toisistaan ja niiden täyttäminen usein vaatii I/O-laitteiden odottamista.
Näistä syistä verkkopalvelinsovellus on hyvä kohde rinnakkaistamiselle.

Yleisesti verkkopalvelimet toteutetaan käyttäen valmista sovelluskehystä eli kirjastoa,
joka toteuttaa palvelinmallin, ja tarjoaa rajapinnat sovelluslogiikan
kehittämistä varten.

Käyttöjärjestelmät tarjoavat kehittäjälle työkaluja, joilla rinnakkaisuuden hallintaan.
Niistä tärkeimpiä ovat prosessit ja säikeet.
Prosessi yksi ohjelma, joka on ajossa järjestelmässä. Sen suoritustilatiedot, ja tunniste on
tallennettu käyttöjärjestelmässä prosessin kuvaajaan~\cite{stallings_operating_2018}.
Jokaisella
prosessilla on oma muistiavaruus, ja prosessien välinen keskustelu
tapahtuu ainoastaan käyttöjärjestelmän tarjoamien rajapintojen läpi~\cite{stallings_operating_2018}.
Prosessi siis käsitteenä mahdollistaa sen että, käyttöjärjestelmä
voi suorittaa useaa ohjelmaa samanaikaisesti ja käyttöjärjestelmän
vuoronantaja jakaa niille suoritusaikaa. Kun prosessi vaihtuu
käyttöjärjestelmä asettaa suorittimen suoritusympäristöksi
uuden prosessin kuvaajaan tallennetun ympäristön. Tätä kutsutaan kontekstin
vaihdoksi. Vanhan prosessin suoritinympäristö puolestaan talletetaan sen 
kuvaajaan~\cite{stallings_operating_2018}.

Nykyisissä käyttöjärjestelmissä voi prosessin suoritusta jakaa usealle
säikeelle. Prosessissa on silloin yksi tai useampia säikeitä.
Säikeet jakavat prosessin muistiavaruuden, sekä tiedostoresurssit.
Säikeiden kuvaajiin
tallennetaan niiden suoritustilatieto,
kuten rekisterien ja pinon arvot~\cite{stallings_operating_2018}.

Koska säikeisiin liittyy vähemmän tietoa, kuin prosesseihin,
on niiden luominen ja tuhoaminen nopeampaa. Säikeiden välinen
kommunikointi on myös huomattavasti nopeampaa kuin prosessien, koska
ne voivat välittää tietoa jakamansa muistialueen läpi.
Prosessit voivat kommunikoida keskenään vain käyttöjärjestelmän 
avulla~\cite{stallings_operating_2018}.
Nopea
kommunikointi tekee rinnakkaisen ohjelman synkronointivaiheista
sujuvampia~\cite{stallings_operating_2018}. Säikeiden vaihdossa suoritinympäristö pitää vaihtaa 
samaan tapaan kuin prosessienkin kohdalla, mutta keskusmuistissa olevia
tietoja ei tarvitse vaihtaa, sillä saman prosessin säikeet jakavat
muistin.

Ytimentasonsäikeet ovat säikeitä joiden aikatauluttamisesta vastaa
käyttöjärjestelmän ydin. Käyttäjätasonsäikeet ovat sellaisia säikeitä,
joiden aikatauluttamisesta vastaa jokin käyttäjätason ohjelma kuten
säiekirjasto. Käyttäjätason aikatauluttamisen puutteista johtuen
kaksi saman prosessin käyttäjätason säiettä ei voi olla suorituksessa
samaan aikaan. Täten ytimentasonsäikeet palvelevat rinnakkaisuuden tavoitteita
paremmin, mutta niiden hallinnointi on raskaampaa~\cite{stallings_operating_2018}.
% Voiko taustatietoa lainata oppikirjoista huoletta ?

Sovelluslogiikan suorittamisen lisäksi rinnakkain voidaan suorittaa I/O-operaatioita.
Käyttöjärjestelmät tarjoavat asynkronisia I/O-kutsuja, joita kutsumalla
sovellus voi jatkaa suoritustaan sillä aikaa kun käyttöjärjestelmä
suorittaa tarvittua I/O-operaatiota. Näitä kutsuja käyttämällä voidaan
lisätä sovelluksen samanaikasuutta lisäämättä säikeitä
tai prosesseja ohjelman rakenteeseen.

\subsection{Tapahtumaohjattu palvelinmalli}

Tapahtumaohjatussa palvelimessa yhdistetään
käyttöliittymäohjelmoinnista lähtöisin oleva tapahtumaohjattu malli
verkkopalvelimeen~\cite{pai_flash:_1999}. Tapahtumaohjattu malli sopii verkkopalvelinsovellukseen,
sillä sen toiminnan rytmittää pyynnöt, jotka
kuvautuvat mallissa tapahtumiksi~\cite{schmidt_reactor:_1995}.
Prosesseihin perustuva asynkroninen AMPED\cite{pai_flash:_1999}
oli erityisen siirrettävä aikana jona, käyttöjärjestelmät
eivät tukeneet säikeitä tai asynkronisia kutsuja.
Myöhemmin näiden ominaisuuksien yleistyessä 
huomiota saaneita malleja ovat Reactor~\cite{schmidt_reactor:_1995}
ja Proactor~\cite{pyarali_proactor_1997}, joissa
rinnakkaisuus saavutetaan asynkronisilla I/O-operaatiolla
ja säikeillä. Nämä mallit ovat yleisiä tapahtumaohjattuja malleja, jotka
vastaavat sovelluksen samanaikaisuuskäytännöstä.
Näitä voidaan soveltaa myös muuhunkin kuin palvelimiin.


Tapahtumaohjattujen palvelinsovelluksien suunnittelun keskiössä
ovat vasteajan pienentäminen ja laitteistoresurssien tehokas hyödyntäminen.
Tavoitteena on hyödyntää I/O-resursseja mahdollisimman tehokkaasti
rinnakkain ja välttää I/O:n odottamista ohjelman suorituksessa~\cite{pai_flash:_1999}.
Palvelinsovelluksissa
laitteiston verkkoliikennekapasiteetti on usein rajoittava tekijä ja tämän takia
sen tehokas hyödyntäminen on kriittistä. I/O-resurssien asynkronisella hyödyntämisellä on todettu
olevan suorituskykyä parantava vaikutus~\cite{hu_applying_1998}.

% miten tulee toimia kun referoin paljon tekstiä jossa malli esitellään ensikerran ?
Reactor-malli sopii käyttötapauksiin, joissa pyyntöjä voi saapua 
samanaikaisesti monista lähteistä ja estävästi
pyyntöjen odottaminen näistä lähteistä olisi tehotonta~\cite{schmidt_reactor:_1995}.
Käyttötapauksen tapahtumankäsittelijöiden, tulisi
lähettää ja vastaanottaa rajoitetun kokoisia viestejä
tarvitsematta estävää I/O:ta. Näiden viestien käsittelyn
pitäisi tapahtua suhteellisen lyhyessä ajassa~\cite{schmidt_reactor:_1995}.
Myös jos kohdelaitteistolla ei ole järkevää käyttää monisäikeistä
ratkaisua pyyntöjen käsittelyn rinnakkaistamiseen tai rinnakkaisuus
on toteutettu muualla järjestelmän arkkitehtuurissa, sopii Reactor-malli
erottamaan sovelluksen ydinlogiikasta tapahtumienkäsittelyn
rinnakkaistammiseen liittyvän logiikan~\cite{schmidt_reactor:_1995}.

Modernissa verkkopalvelinsovelluksessa Reactor-mallin suosioon on
monta syytä. RESTful-rajapinnan käyttäminen
verkkopalvelinsovelluksessa viestien välitykseen,
saa viestien koon pysymään pienenä ja viestien
käsittelyyn kuluvan ajan lyhyempänä verrattuna
HTML-tiedosto vastaukseen[lähde?]. % Etsi joku REST-lähde
Monisäikeisyys ja rinnakkaistaminen
voidaan järjestelmän arkkitehtuurissa siirtää tietokantamoottorin vastuulle,
jolloin verkkopalvelin voi lähettää sille asynkronisia kyselyitä
ja näin suorittaa useisiin pyyntöihin liittyviä tietokantakyselyitä
samanaikaisesti.
Tämänkaltaisella toteutuksella verkkopalvelimen käyttötapaus sopii
hyvin yhteen Reactor-mallin määrittelyn kanssa tukeutuen 
mallin vahvuuksiin sekä peittäen sen heikkouksia.

Reactor mallissa pyyntöjen käsittelystä
vastaa tapahtumasäie.
Tapahtumasäie kutsuu tapahtumajonon jokaista tapahtumaa kohden, sille
määriteltyä tapahtumakäsittelijää.
Tapahtumakäsittelijöissä rinnakkaisuuteen päästään
vain I/O:n osalta, kun käytetään asynkronisia
I/O-operaatiota.
Estäviä operaatioita tulee välttää,
sillä niiden käyttäminen laskee sovelluksen
vastaavuutta huomattavasti~\cite{schmidt_reactor:_1995}.
Asynkronisia I/O-operaatioita 
voidaan suorittaa niitä tarjoavien käyttöjärjestelmä kutsujen
avulla, tai siirtämällä I/O-operaatiot toisen säikeen tehtäväksi.
Itse Reactor-malli ei ota kantaa miten asynkroninen operaatio toteutetaan.
Jos tapahtumakäsittelijässä tarvitaan pitkäkestoista laskentaa
kannattaa sitä varten luoda uusi prosessi tai säie. Tämä
prosessi tai säie saattaa pyynnön loppuun rinnakkain 
Reactorin tapahtumasäikeen kanssa~\cite{schmidt_reactor:_1995}.

Proactor mallissa on paljon yhtäläisyyksiä Reactor malliin, mutta siinä
hyödynnetään käyttöjärjestelmän asynkronisia ominaisuuksia suorittamaan
operaatiota ennen pyynnön saapumista tapahtumasäikeelle~\cite{pyarali_proactor_1997}.
Tapahtumasäie ohjaa tässä mallissa asynkronisten tapahtumien 
valmistumistapahtumia niitä vastaaville tapahtumankäsittelijöille~\cite{pyarali_proactor_1997}.

Mikään ei kuitenkaan estä luomasta asynkronisten tapahtumien valmistumisille
tapahtumankäsittelijöitä
Reactor-mallissa ja näin tehdään monissa implementaatioissa Future-tai Promise nimisillä
abstraktiolla.

Toinen Reactor mallin laajennus on SEDA (Staged Event Driven Architecture)~\cite{welsh_seda_2001}.
Siinä pyyntöjen käsittely jaetaan tasoiksi, joissa kaikissa on
käytännössä reactor-mallin toteuttava rakenne. Jokaisella tasolla
on oma tapahtumajono sekä tapahtumakäsittelijä, joka ohjaa työtä
apusäikeille. Tasoilla ei ole tapahtumasäiettä, sillä
jokaisella tasolla on vain yksi tapahtumakäsittelijä.
Tapahtumakäsittelijä voi käsittelyn päätteeksi
lisätä uusia tapahtumia seuraavien tasojen tapahtumajonoihin.
Tämän lisäksi jokaisella tasolla on resurssiohjaaja,
joka vastaa resurssien käytön pysymisestä sallitulla tasolla,
sekä apusäikeiden määrästä kyseisellä tasolla~\cite{welsh_seda_2001}.
SEDA-arkkitehtuurin suurin ero suoraan Reactor-mallin pohjalta luotuun
palvelimeen on sen hienojakoisempi resurssien ohjaus sovelluksen eri tasoille.

Tässä tutkielmassa keskitytään erityisesti
reactor-malliin, sillä se on sisäänrakennettu Node.js ohjelmaympäristöön ja
täten paljon käytetty. Node.js:n reactor-mallin toteuttamisesta vastaa
libuv-kirjasto~\cite{libuv_design_2019}. Suunnittelufilosofiassa
libuv:lla on paljon yhteistä AMPED-mallin kanssa, sillä
sen tarkoitus on taata aina asynkroniset I/O-operaatiot alustasta
riippumatta. Libuv siirtääkin I/O-kutsun toiselle säikeelle
jos alustalla ei ole tarjota asynkronista kutsua natiivisti~\cite{libuv_design_2019}.
Tämä toimintapa saa kutsun näyttämään tapahtumankäsittelijästä
asynkroniselta.

Reactor-mallia voi laajentaa vielä kolmannella tavalla.
Jos samaa Reactor-sovellusta ajaa yhdessä eri säikeillä
ja jokin säie jakaa työn tasaisesti tapahtumasäikeiden välillä
on kyseessä SYMPED-malli. Tämä malli mahdollistaa
Reactor pohjaisten sovelluksien skaalaamisen tehokkaasti.

\subsection{Säiereservimalli}
Monisäikeisiä palvelinmalleja on useita, mutta tässä tutkielmassa keskitytään säiereservimalliin.
Monisäikeiset mallit ovat käytännössä syrjäyttäneet moniprosessimallin,
sillä palvelimien käyttöjärjestelmät tukevat säikeitä, ja säikeiden hallinnointiin
kuluu vähemmän resursseja kuin prosessien ja niiden välinen kommunikointi on sujuvampaa.
Moniprosessimallia käytetään kuitenkin yhä, kun järjestelmä pitää
saada skaalautumaan usealle laitteistolle.

Monisäikeisissä palvelinsovelluksissa hyödynnetään laitteiston
rinnakkaisuutta tehokkaasti suorittamalla pyyntöjä usealla säikeellä rinnakkain.
Suunnittelun keskeisenä tavoitteena on käsitellä mahdollisimman monta pyyntöä rinnakkain ja 
näin saavuttaa korkea volyymi. Yksittäisen pyynnön
vasteaika saattaa tässä
järjestelmässä kärsiä säikeiden hallinnoimiseen kuluvasta suoritinajasta~\cite{easton_developing_2004}.

Pääsääntöisesti nämä mallit skaalautuvat hyvin laitteistoresursseihin,
mutta jos hallinnoitavien säikeiden määrä on huomattavasti suurempi kuin laitteiston
fyysisten suorittimien määrä, aiheuttaa hallinnointi ylimääräistä taakkaa.
Kalleimmat hallinnointitehtävät ovat säikeiden luonti ja tuhoaminen, sillä
muistin varaus- ja vapautusoperaatiot vievät paljon aikaa~\cite{ling_analysis_2000}.
Näihin operaatioihin kuluva aika onkin suurin säie-yhteyttä-kohti mallin
ongelma, jossa jokaista pyyntöä kohti
luodaan uusi säie, joka vastaamisen jälkeen tuhotaan.
Tämän mallin ongelmia on pyritty ratkaisemaan säiereservimallilla.

Säiereservimalli pyrkii minimoimaan tämän ongelman rajoittamalla
säikeiden määrän johonkin järkevään arvoon, kuten fyysisten suorittimien
määrään. Se käyttää samoja säikeitä uudestaan, eli se ei tuhoa säiettä
pyynnön käsittelyn päätteeksi vaan jättää sen vapaaksi säikeeksi reserviin~\cite{ling_analysis_2000}.

Säiereservimallissa asiakkaan pyyntöjen käsittely tapahtuu seuraavasti.
Kun pyyntö saapuu, se osoitetaan vapaalle säikeelle. Säie käsittelee pyyntöä ja,
jos se jää odottamaan I/O:ta asetetaan säikeen tila suorittaa-tilasta odottaa-tilaan,
jolloin käyttöjärjestelmän vuoronantaja voi antaa suoritinaikaa toiselle säikeelle,
kunnes I/O-pyyntö valmistuu. Kun pyyntö on käsitelty ja siihen on vastattu, niin
säie siirretään takaisin reserviin~\cite{ling_analysis_2000}.

Menetelmässä pyyntöjen käsittely on hyvin eristetty toisistaan ja
yhden säikeen lukittava tapahtuma ei vaikuta muihin säikeisiin negatiivisesti~\cite{davis_case_2017}.
Tämä edistää monisäikeisen mallin vakautta ja kykyä vastustaa hyökkäyksiä.
Tämä malli on myös ohjelmoijalle yksinkertainen sillä, pyyntöjen jakamaa tilatietoa
ja synkronointia on vähän~\cite{hu_applying_1998}.

Säiereservin oikean kapasiteetin valitseminen on erittäin kriittinen 
järjestelmän suorituskyvylle.
Väärin valittu reservin koko kumoaa kaiken hyödyn, mitä luomisoperaatioiden
ja tuhoamisoperaatioiden välttämisellä on saavutettu~\cite{ling_analysis_2000}.

Joissain toteutuksissa kokoa voi myös muuttaa dynaamisesti ajon aikana vastaamaan
reaaliaikaiseen tarpeeseen.
Tunnettuja säiereservimallin toteutuksia ovat MySQL, sekä Apache Tomcat.

\section{Mallit testeissä}
\subsection{Arviontikriteerit}
Palvelimen roolin kannalta olisi toivottavaa, että
se pystyisi käsittelemään mahdollisimman paljon pyyntöjä
ajan yksikössä. Sen tulisi pystyä myös käsittelemään pyyntöjä
luotettavasti eli lopulta kaikki pyynnöt käsitellään ja niihin vastataan.
Yksittäiselle asiakkaalle tärkein suorituskyvyn mittari on se kuinka kauan
yksittäiseen pyyntöön vastaaminen vie. Pyynnön matala vasteaika saa
palvelun käyttökokemuksen tuntumaan sujuvammalta.
Skaalautuvuus on tärkeää palvelinta ylläpitävälle taholle, sillä
näin käyttäjämäärän kasvaessa voidaan suorituskykyä parantaa
lisäämällä laitteistoresursseja. Järjestelmän tulisi myös
olla vastustuskykyinen hyökkäyksille.

Näiden ajatusten ja aikaisemman tutkimuksen perusteella
tutkielmassa vertailtavia järjestelmiä arvioidaan seuraavien
kriteerien valossa~\cite{gokhale_performance_2006}.
\begin{itemize}
    \item käsiteltyjen pyyntöjen määrä eli volyymi
    \item menetysprosentti
    \item skaalautuvuus laitteistoresursseihin
    \item vasteaika
    \item vakaus
\end{itemize}
\subsection{Tietoturva}

Reactor-mallin järjestelmissä suoritinsidonnaisien
operaatioiden rinnakkaistamiseen ei ole keskitetty erityistä huomiota, ja tällaisten operaatioiden
kanssa järjestelmän käsiteltyjen pyyntöjen määrä ajan yksikössä on keskimäärin heikompi
kuin monisäikeisten järjestelmien~\cite{davis_case_2017}.

Reactor-mallin skaalautuvuus kasvaviin laitteistoresursseihin on hyvin
toteutussidonnaista, kun taas

säiereservimallin skaalautuvuus suoritinresursseihin on hyvin suoraviivaista,
vaikkakin kilpailutilanteiden havaitsemiseen ja estämiseen kuluu enemmän aikaa,
jos säikeitä on paljon.

Reactor-mallin palvelimeen voi kohdistaa hyökkäyksiä, jolla pyritään
lukitsemaan tapahtumia käsittelevä säie, joka käytännössä vastaa koko ohjelman hallinnasta.
Tähän tarkoitukseen sopivat pyynnöt,
joiden käsittelyyn liittyy kompleksista säännöllisten lauseiden käsittelyä.
Osoitepolkujen selvittämiseen liittyy usein säännöllisiä lausekkeita,
joten verkkopalvelimet ja niiden
kehykset voivat olla alttiita tämänkaltaisille hyökkäyksille~\cite{davis_case_2017}.

Tällaiset hyökkäykset aiheuttaisivat ongelmia myös säiereservimallia
noudattaville järjestelmille, mutta niiden pitäisi onnistua
lukitsemaan reservin jokainen säie samaan aikaan, jotta
järjestelmä ei kykenisi enää vastaamaan asiakkaiden pyyntöihin~\cite{davis_case_2017}.

\subsection{Järjestelmien volyymin ja skaalautuvuuden testit simulaatiolla}
Vuonna 1997 James C. Hu et.al testeissään~\cite{hu_measuring_1997}huomasivat
että pienillä tiedostoilla säiereservimalli oli paras,
mutta suuremmilla tiedostoilla asynkroninen I/O-operaatioiden
tekeminen tapahtumaohjatulla palvelimella oli kaikista tehokkain.
Testissä asynkronisia operaatioita hidasti
erityisesti TransmitFile-funktio, joka oli 
hidas pienillä tiedostoilla.
Tästä tuloksesta voidaan kuitenkin huomata,
että suurilla tiedostoilla saadaan asynkronisilla
kutsuilla aikaan enemmän I/O:n rinnakkaisuutta, sillä
työ siirtyy käyttöjärjestelmän vastuulle.

Ivan Voras ja Mario Zagar totesivat testeissään~\cite{voras_characteristics_2009},
että heidän SEDA-implementaationsa kahdella tapahtumasäikeellä ja 4 apusäikeellä
ei saavuttanut huomattavaa
etua yksinkertaiseen Reactor-toteutukseen. Tämän diagnosoitiin
johtuvan SEDA:n aiheuttamien suorittimen kontekstinvaihtojen yleisyydestä.
Testissä molemmat järjestelmien suorituskyky
oli lähes samalla 120:neen asiakkaaseen asti jonka
jälkeen SPED-järjestelmän suorituskyky alkoi
hieman heikentyä. SPED suoritti silloin noin 110 000 toimitusta sekunnissa
ja SEDA 120 000 sekunnissa. Samassa testissä AMPED-järjestelmä neljällä apuprosessilla
kykeni 250 000 toimitukseen sekunnissa 120:nellä asiakkaalla. Mielenkiintoista on
että heidän SEDA-implementaatio, jossa tapahtumasäikeiden ja apusäikeiden
määrät asetettiin samaksi arvoksi suoritutui huomattavasti paremmin ja
saavutti 300 000 tapahtumaa sekunnissa 120:nellä asiakkaalla.
Vertailun selkein voittaja skaalautuvuuden
osalla oli SYMPED-järjestelmä, jossa on useita SPED-järjestelmiä
omilla säikeillään. Tällä järjestelmällä neljällä säikeellä
saavutettiin 440 toimitusta sekunnissa 120:nellä asiakkaalla.

\section{Johtopäätökset}
Reactor mallin rajallisuudet rinnakkaisuudessa
eivät ole haitaksi, jos järjestelmässä on rinnakkaisuutta
korkeammalla tai matalammalla tasolla.

Reactor-mallin on erottaa 
selkeästi pyyntöjen käsittelyn 
samanaikaistamiseen liittyvän
logiikan, muusta sovelluskohtaisesta logiikasta.
Malli on myös suhteessa muihin samanaikaisuutta
käsitteleviin malleihin yksinkertainen.
Näistä syistä se on implementoitu useisiin
kirjastoihin ja saavuttanut vakaan suosion.

Reactor-mallin implentoivalla 
kirjastolla voidaan kustannustehokkaasti
toteuttaa palvelin, joka kykenee suoritutumaan
tehtävistään palvelun alkutaipaleella. Jos
käyttäjä määrät kasvavat ja skaalautuvuutta
vaaditaan voidaan järjestelmä muuttaa SYMPED-järjestelmäksi
joka todetusti skaalautuu hyvin resuresseihin.
Node.js sovelluksesta voi luoda SYMPED järjestelmän
cluster-kirjastolla.
\bibliography{kandi_zot}
\bibliographystyle{plain}

\end{document}
