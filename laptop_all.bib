
@article{yang_making_2014,
	title = {Making {Parallel} {Programs} {Reliable} with {Stable} {Multithreading}},
	volume = {57},
	issn = {0001-0782},
	url = {http://doi.acm.org/10.1145/2500875},
	doi = {10.1145/2500875},
	abstract = {Stable multithreading dramatically simplifies the interleaving behaviors of parallel programs, offering new hope for making parallel programming easier.},
	number = {3},
	urldate = {2019-02-12},
	journal = {Commun. ACM},
	author = {Yang, Junfeng and Cui, Heming and Wu, Jingyue and Tang, Yang and Hu, Gang},
	month = mar,
	year = {2014},
	pages = {58--69},
	file = {ACM Full Text PDF:/home/vililipo/Zotero/storage/56SHC7IF/Yang ym. - 2014 - Making Parallel Programs Reliable with Stable Mult.pdf:application/pdf}
}

@article{chronaki_maturity_2019,
	title = {On the maturity of parallel applications for asymmetric multi-core processors},
	volume = {127},
	issn = {0743-7315},
	url = {http://www.sciencedirect.com/science/article/pii/S0743731519300267},
	doi = {10.1016/j.jpdc.2019.01.007},
	abstract = {Asymmetric multi-cores (AMCs) are a successful architectural solution for both mobile devices and supercomputers. By maintaining two types of cores (fast and slow) AMCs are able to provide high performance under the facility power budget. This paper performs the first extensive evaluation of how portable are the current HPC applications for such supercomputing systems. Specifically we evaluate several execution models on an ARM big.LITTLE AMC using the PARSEC benchmark suite that includes representative highly parallel applications. We compare schedulers at the user, OS and runtime levels, using both static and dynamic options and multiple configurations, and assess the impact of these options on the well-known problem of balancing the load across AMCs. Our results demonstrate that scheduling is more effective when it takes place in the runtime system level as it improves the baseline by 23\%, while the heterogeneous-aware OS scheduling solution improves the baseline by 10\%.},
	urldate = {2019-02-12},
	journal = {Journal of Parallel and Distributed Computing},
	author = {Chronaki, Kallia and Moretó, Miquel and Casas, Marc and Rico, Alejandro and Badia, Rosa M. and Ayguadé, Eduard and Valero, Mateo},
	month = may,
	year = {2019},
	keywords = {Asymmetric multi-cores, HPC, Parallel programming, Runtime systems, Scheduling},
	pages = {105--115},
	file = {ScienceDirect Full Text PDF:/home/vililipo/Zotero/storage/37U2RG39/Chronaki ym. - 2019 - On the maturity of parallel applications for asymm.pdf:application/pdf;ScienceDirect Snapshot:/home/vililipo/Zotero/storage/QSNJZ6NJ/S0743731519300267.html:text/html}
}

@article{wilde_swift:_2011,
	series = {Emerging {Programming} {Paradigms} for {Large}-{Scale} {Scientific} {Computing}},
	title = {Swift: {A} language for distributed parallel scripting},
	volume = {37},
	issn = {0167-8191},
	shorttitle = {Swift},
	url = {http://www.sciencedirect.com/science/article/pii/S0167819111000524},
	doi = {10.1016/j.parco.2011.05.005},
	abstract = {Scientists, engineers, and statisticians must execute domain-specific application programs many times on large collections of file-based data. This activity requires complex orchestration and data management as data is passed to, from, and among application invocations. Distributed and parallel computing resources can accelerate such processing, but their use further increases programming complexity. The Swift parallel scripting language reduces these complexities by making file system structures accessible via language constructs and by allowing ordinary application programs to be composed into powerful parallel scripts that can efficiently utilize parallel and distributed resources. We present Swift’s implicitly parallel and deterministic programming model, which applies external applications to file collections using a functional style that abstracts and simplifies distributed parallel execution.},
	number = {9},
	urldate = {2019-02-12},
	journal = {Parallel Computing},
	author = {Wilde, Michael and Hategan, Mihael and Wozniak, Justin M. and Clifford, Ben and Katz, Daniel S. and Foster, Ian},
	month = sep,
	year = {2011},
	keywords = {Parallel programming, Dataflow, Scripting, Swift},
	pages = {633--652},
	file = {ScienceDirect Full Text PDF:/home/vililipo/Zotero/storage/XG2JUWI8/Wilde ym. - 2011 - Swift A language for distributed parallel scripti.pdf:application/pdf;ScienceDirect Snapshot:/home/vililipo/Zotero/storage/HVL8MM44/S0167819111000524.html:text/html}
}

@article{hwu_implicitly_nodate,
	title = {Implicitly {Parallel} {Programming} {Models} for {Thousand}-{Core} {Microprocessors}},
	abstract = {This paper argues for an implicitly parallel programming model for many-core microprocessors, and provides initial technical approaches towards this goal. In an implicitly parallel programming model, programmers maximize algorithmlevel parallelism, express their parallel algorithms by asserting high-level properties on top of a traditional sequential programming language, and rely on parallelizing compilers and hardware support to perform parallel execution under the hood. In such a model, compilers and related tools require much more advanced program analysis capabilities and programmer assertions than what are currently available so that a comprehensive understanding of the input program’s concurrency can be derived. Such an understanding is then used to drive automatic or interactive parallel code generation tools for a diverse set of parallel hardware organizations. The chip-level architecture and hardware should maintain parallel execution state in such a way that a strictly sequential execution state can always be derived for the purpose of verifying and debugging the program. We argue that implicitly parallel programming models are critical for addressing the software development crises and software scalability challenges for many-core microprocessors.},
	language = {en},
	author = {Hwu, Wen-mei and Ryoo, Shane and Ueng, Sain-Zee and Kelm, John H and Gelado, Isaac and Stone, Sam S and Kidd, Robert E and Baghsorkhi, Sara S and Mahesri, Aqeel A and Tsao, Stephanie C and Navarro, Nacho and Lumetta, Steve S and Frank, Matthew I and Patel, Sanjay J},
	pages = {6},
	file = {Hwu et al. - Implicitly Parallel Programming Models for Thousan.pdf:/home/vililipo/Zotero/storage/4DN9WYVL/Hwu et al. - Implicitly Parallel Programming Models for Thousan.pdf:application/pdf}
}

@inproceedings{hwu_implicitly_nodate-1,
	title = {Implicitly {Parallel} {Programming} {Models} for {Thousand}-{Core} {Microprocessors}},
	abstract = {This paper argues for an implicitly parallel programming model for many-core microprocessors, and provides initial technical approaches towards this goal. In an implicitly parallel programming model, programmers maximize algorithmlevel parallelism, express their parallel algorithms by asserting high-level properties on top of a traditional sequential programming language, and rely on parallelizing compilers and hardware support to perform parallel execution under the hood. In such a model, compilers and related tools require much more advanced program analysis capabilities and programmer assertions than what are currently available so that a comprehensive understanding of the input program’s concurrency can be derived. Such an understanding is then used to drive automatic or interactive parallel code generation tools for a diverse set of parallel hardware organizations. The chip-level architecture and hardware should maintain parallel execution state in such a way that a strictly sequential execution state can always be derived for the purpose of verifying and debugging the program. We argue that implicitly parallel programming models are critical for addressing the software development crises and software scalability challenges for many-core microprocessors.},
	language = {en},
	author = {Hwu, Wen-mei and Ryoo, Shane and Ueng, Sain-Zee and Kelm, John H and Gelado, Isaac and Stone, Sam S and Kidd, Robert E and Baghsorkhi, Sara S and Mahesri, Aqeel A and Tsao, Stephanie C and Navarro, Nacho and Lumetta, Steve S and Frank, Matthew I and Patel, Sanjay J},
	pages = {6},
	file = {Hwu et al. - Implicitly Parallel Programming Models for Thousan.pdf:/home/vililipo/Zotero/storage/G6WKZK2W/Hwu et al. - Implicitly Parallel Programming Models for Thousan.pdf:application/pdf}
}

@inproceedings{loring_semantics_2017,
	address = {Vancouver, BC, Canada},
	title = {Semantics of asynchronous {JavaScript}},
	isbn = {978-1-4503-5526-1},
	url = {http://dl.acm.org/citation.cfm?doid=3133841.3133846},
	doi = {10.1145/3133841.3133846},
	language = {en},
	urldate = {2019-02-12},
	booktitle = {Proceedings of the 13th {ACM} {SIGPLAN} {International} {Symposium} on on {Dynamic} {Languages}  - {DLS} 2017},
	publisher = {ACM Press},
	author = {Loring, Matthew C. and Marron, Mark and Leijen, Daan},
	year = {2017},
	pages = {51--62},
	file = {Loring et al. - 2017 - Semantics of asynchronous JavaScript.pdf:/home/vililipo/Zotero/storage/HBLP2PGG/Loring et al. - 2017 - Semantics of asynchronous JavaScript.pdf:application/pdf}
}

@inproceedings{zhu_microarchitectural_2015,
	address = {Waikiki, Hawaii},
	title = {Microarchitectural implications of event-driven server-side web applications},
	isbn = {978-1-4503-4034-2},
	url = {http://dl.acm.org/citation.cfm?doid=2830772.2830792},
	doi = {10.1145/2830772.2830792},
	abstract = {Enterprise Web applications are moving towards serverside scripting using managed languages. Within this shifting context, event-driven programming is emerging as a crucial programming model to achieve scalability. In this paper, we study the microarchitectural implications of server-side scripting, JavaScript in particular, from a unique event-driven programming model perspective. Using the Node.js framework, we come to several critical microarchitectural conclusions. First, unlike traditional server-workloads such as CloudSuite and BigDataBench that are based on the conventional threadbased execution model, event-driven applications are heavily single-threaded, and as such they require signiﬁcant singlethread performance. Second, the single-thread performance is severely limited by the front-end inefﬁciencies of today’s server processor microarchitecture, ultimately leading to overall execution inefﬁciencies. The front-end inefﬁciencies stem from the unique combination of limited intra-event code reuse and large inter-event reuse distance. Third, through a deep understanding of event-speciﬁc characteristics, architects can mitigate the front-end inefﬁciencies of the managed-languagebased event-driven execution via a combination of instruction cache insertion policy and prefetcher.},
	language = {en},
	urldate = {2019-02-12},
	booktitle = {Proceedings of the 48th {International} {Symposium} on {Microarchitecture} - {MICRO}-48},
	publisher = {ACM Press},
	author = {Zhu, Yuhao and Richins, Daniel and Halpern, Matthew and Reddi, Vijay Janapa},
	year = {2015},
	pages = {762--774},
	file = {Zhu et al. - 2015 - Microarchitectural implications of event-driven se.pdf:/home/vililipo/Zotero/storage/Z5VWZ9KU/Zhu et al. - 2015 - Microarchitectural implications of event-driven se.pdf:application/pdf}
}

@article{faes_concurrency-aware_2018,
	title = {Concurrency-aware {Object}-oriented {Programming} with {Roles}},
	volume = {2},
	issn = {2475-1421},
	url = {http://doi.acm.org/10.1145/3276500},
	doi = {10.1145/3276500},
	abstract = {Object-oriented Programming has been effective in reducing code complexity in sequential programs, but in current practice, concurrent programs still present a number of challenges. We present here a model of object-oriented programming that identifies concurrent tasks and the relationship between objects and tasks, effectively making objects concurrency-aware. This awareness is formalized in a parallel programming model where every object plays a role in every task (e.g., the readonly role). When an object is shared with a new task, it adapts to the new sharing pattern by changing its roles, and therefore its behavior, i.e., the operations that can be performed with this object. This mechanism can be leveraged to prevent interfering accesses from concurrently executing tasks, and therefore makes parallel execution deterministic.  To this end, we present a role-based programming language that includes several novel concepts (role transitions, guarding, slicing) to enable practical, object-oriented deterministic parallel programming. We show that this language can be used to safely implement programs with a range of different parallel patterns. The implementations to 8 widely used programming problems achieve substantial parallel speedups and demonstrate that this approach delivers performance roughly on par with manually synchronized implementations.},
	number = {OOPSLA},
	urldate = {2019-02-12},
	journal = {Proc. ACM Program. Lang.},
	author = {Faes, Michael and Gross, Thomas R.},
	month = oct,
	year = {2018},
	keywords = {concurrency, determinism, parallelism, programming models},
	pages = {130:1--130:30},
	file = {ACM Full Text PDF:/home/vililipo/Zotero/storage/Y3NDY84X/Faes and Gross - 2018 - Concurrency-aware Object-oriented Programming with.pdf:application/pdf}
}

@article{daloze_parallelization_2018,
	title = {Parallelization of dynamic languages: synchronizing built-in collections},
	volume = {2},
	issn = {24751421},
	shorttitle = {Parallelization of dynamic languages},
	url = {http://dl.acm.org/citation.cfm?doid=3288538.3276478},
	doi = {10.1145/3276478},
	language = {en},
	number = {OOPSLA},
	urldate = {2019-02-12},
	journal = {Proceedings of the ACM on Programming Languages},
	author = {Daloze, Benoit and Tal, Arie and Marr, Stefan and Mössenböck, Hanspeter and Petrank, Erez},
	month = oct,
	year = {2018},
	pages = {1--30},
	file = {Daloze et al. - 2018 - Parallelization of dynamic languages synchronizin.pdf:/home/vililipo/Zotero/storage/B9LBCJZX/Daloze et al. - 2018 - Parallelization of dynamic languages synchronizin.pdf:application/pdf}
}

@inproceedings{gokhale_performance_2006,
	title = {Performance and {Reliability} {Analysis} {ofWeb} {Server} {Software} {Architectures}},
	doi = {10.1109/PRDC.2006.50},
	abstract = {Our increasing reliance on the information and services provided by modern Web servers mandates that these services be offered with superior performance and reliability. The architecture of a Web server has a profound impact on its performance and reliability. One of the dimensions used to characterize the architecture of a Web server is the processing model employed in the server, which describes the type of process or threading model used to support a Web server operation. The main options for a processing model are process-based, thread-based or a hybrid of the process-based and the thread-based models. These options have unique advantages and disadvantages in terms of their performance and reliability tradeoffs. In this paper we propose an analysis methodology based on the stochastic reward net (SRN) modeling paradigm to quantify the performance and the reliability tradeoffs in the process-based and the thread-based Web server software architectures. We demonstrate the capability of the methodology to facilitate systematic, quantitative tradeoffs using several examples},
	booktitle = {2006 12th {Pacific} {Rim} {International} {Symposium} on {Dependable} {Computing} ({PRDC}'06)},
	author = {Gokhale, S. S. and Vandal, P. J. and Lu, J.},
	month = dec,
	year = {2006},
	keywords = {client server system, client-server systems, Computer architecture, Computer crashes, Costs, Internet, multi-threading, Performance analysis, Petri nets, process-based model, reliability tradeoff, Service oriented architecture, software architecture, Software architecture, software reliability, Stochastic processes, stochastic reward net, thread-based model, Web server, World Wide Web, Yarn},
	pages = {351--358},
	file = {IEEE Xplore Abstract Record:/home/vililipo/Zotero/storage/K2Y8AUKU/4041921.html:text/html;IEEE Xplore Full Text PDF:/home/vililipo/Zotero/storage/63GUKD9R/Gokhale et al. - 2006 - Performance and Reliability Analysis ofWeb Server .pdf:application/pdf}
}

@inproceedings{davis_impact_2018,
	address = {Lake Buena Vista, FL, USA},
	title = {The impact of regular expression denial of service ({ReDoS}) in practice: an empirical study at the ecosystem scale},
	isbn = {978-1-4503-5573-5},
	shorttitle = {The impact of regular expression denial of service ({ReDoS}) in practice},
	url = {http://dl.acm.org/citation.cfm?doid=3236024.3236027},
	doi = {10.1145/3236024.3236027},
	abstract = {Regular expressions (regexes) are a popular and powerful means of automatically manipulating text. Regexes are also an understudied denial of service vector (ReDoS). If a regex has super-linear worst-case complexity, an attacker may be able to trigger this complexity, exhausting the victim’s CPU resources and causing denial of service. Existing research has shown how to detect these superlinear regexes, and practitioners have identified super-linear regex anti-pattern heuristics that may lead to such complexity. In this paper, we empirically study three major aspects of ReDoS that have hitherto been unexplored: the incidence of super-linear regexes in practice, how they can be prevented, and how they can be repaired. In the ecosystems of two of the most popular programming languages Ð JavaScript and Python ś we detected thousands of super-linear regexes affecting over 10,000 modules across diverse application domains. We also found that the conventional wisdom for super-linear regex anti-patterns has few false negatives but many false positives; these anti-patterns appear to be necessary, but not sufficient, signals of super-linear behavior. Finally, we found that when faced with a super-linear regex, developers favor revising it over truncating input or developing a custom parser, regardless of whether they had been shown examples of all three fix strategies. These findings motivate further research into ReDoS, since many modules are vulnerable to it and existing mechanisms to avoid it are insufficient. We believe that ReDoS vulnerabilities are a larger threat in practice than might have been guessed.},
	language = {en},
	urldate = {2019-03-04},
	booktitle = {Proceedings of the 2018 26th {ACM} {Joint} {Meeting} on {European} {Software} {Engineering} {Conference} and {Symposium} on the {Foundations} of {Software} {Engineering}  - {ESEC}/{FSE} 2018},
	publisher = {ACM Press},
	author = {Davis, James C. and Coghlan, Christy A. and Servant, Francisco and Lee, Dongyoon},
	year = {2018},
	pages = {246--256},
	file = {Davis et al. - 2018 - The impact of regular expression denial of service.pdf:/home/vililipo/Zotero/storage/6AWCGJTA/Davis et al. - 2018 - The impact of regular expression denial of service.pdf:application/pdf}
}

@inproceedings{hu_applying_1998,
	title = {Applying {The} {Proactor} {Pattern} {To} {High}-{Performance} {Web} {Servers}},
	abstract = {Modern operating systems provide multiple concurrency mechanisms to develop high-performance Web servers. Synchronous multi-threading is a popular mechanism for developing Web servers that must perform multiple operations simultaneously to meet their performance requirements. In addition, an increasing number of operating systems support asynchronous mechanisms that provide the benefits of concurrency, while alleviating much of the performance overhead of synchronous multi-threading. This paper provides two contributions to the study of high-performance Web servers. First, it examines how synchronous and asynchronous event dispatching mechanisms impact the design and performance of JAWS, which is our high-performance Web server framework. The results reveal significant performance improvements when a proactive concurrency model is used to combine lightweight concurrency with asynchronous event dispatching. In general, however, the complexity of the proactive concurrency model makes it ...},
	booktitle = {In {Proceedings} of the 10th {International} {Conference} on {Parallel} and {Distributed} {Computing} and {Systems}},
	author = {Hu, James and Pyarali, Irfan and Schmidt, Douglas C.},
	year = {1998},
	file = {Citeseer - Full Text PDF:/home/vililipo/Zotero/storage/59DS4828/Hu et al. - 1998 - Applying The Proactor Pattern To High-Performance .pdf:application/pdf;Citeseer - Snapshot:/home/vililipo/Zotero/storage/LJS9NUTX/summary.html:text/html}
}

@incollection{easton_developing_2004,
	address = {Berkeley, CA},
	title = {Developing {Distributed} {Applications}},
	isbn = {978-1-4302-5365-5 978-1-4302-0746-7},
	url = {http://link.springer.com/10.1007/978-1-4302-0746-7_6},
	abstract = {The ADAPTIVE Service eXecutive (ASX) is a highly modular and extensible object-oriented framework that simpliﬁes the development and conﬁguration of distributed applications on shared memory multi-processor platforms. This paper describes the structure and functionality of the ASX framework’s object-oriented architecture. In addition, the paper presents the results of performance experiments conducted using ASX-based implementations of connection-oriented and connectionless protocols from the TCP/IP protocol family. These experiments measure the performance impact of alternative methods for parallelizing communication protocol stacks. Throughout the paper, examples are presented to indicate how the use of object-oriented techniques facilitate application extensibility, component reuse, and performance enhancement.},
	language = {en},
	urldate = {2019-03-05},
	booktitle = {Cross-{Platform} .{NET} {Development}: {Using} {Mono}, {Portable}.{NET}, and {Microsoft} .{NET}},
	publisher = {Apress},
	author = {Easton, M. J. and King, Jason},
	collaborator = {Easton, M. J. and King, Jason},
	year = {2004},
	doi = {10.1007/978-1-4302-0746-7_6},
	pages = {201--266},
	file = {Easton and King - 2004 - Developing Distributed Applications.pdf:/home/vililipo/Zotero/storage/BM2QUBGB/Easton and King - 2004 - Developing Distributed Applications.pdf:application/pdf}
}

@article{ocallahan_hybrid_nodate,
	title = {Hybrid {Dynamic} {Data} {Race} {Detection}},
	abstract = {We present a new method for dynamically detecting potential data races in multithreaded programs. Our method improves on the state of the art in accuracy, in usability, and in overhead. We improve accuracy by combining two previously known race detection techniques — lockset-based detection and happens-before-based detection — to obtain fewer false positives than lockset-based detection alone. We enhance usability by reporting more information about detected races than any previous dynamic detector. We reduce overhead compared to previous detectors — particularly for large applications such as Web application servers — by not relying on happens-before detection alone, by introducing a new optimization to discard redundant information, and by using a “two phase” approach to identify error-prone program points and then focus instrumentation on those points. We justify our claims by presenting the results of applying our tool to a range of Java programs, including the widely-used Web application servers Resin and Apache Tomcat. Our paper also presents a formalization of lockset-based and happens-before-based approaches in a common framework, allowing us to prove a “folk theorem” that happens-before detection reports fewer false positives than lockset-based detection (but can report more false negatives), and to prove that two key optimizations are correct.},
	language = {en},
	author = {O’Callahan, Robert and Choi, Jong-Deok},
	pages = {12},
	file = {O’Callahan and Choi - Hybrid Dynamic Data Race Detection.pdf:/home/vililipo/Zotero/storage/2SGDAACT/O’Callahan and Choi - Hybrid Dynamic Data Race Detection.pdf:application/pdf}
}

@article{guo_bcube:_nodate,
	title = {{BCube}: a high performance, server-centric network architecture for modular data centers},
	abstract = {This paper presents BCube, a new network architecture speciﬁcally designed for shipping-container based, modular data centers. At the core of the BCube architecture is its server-centric network structure, where servers with multiple network ports connect to multiple layers of COTS (commodity oﬀ-the-shelf) mini-switches. Servers act as not only end hosts, but also relay nodes for each other. BCube supports various bandwidth-intensive applications by speedingup one-to-one, one-to-several, and one-to-all traﬃc patterns, and by providing high network capacity for all-to-all traﬃc. BCube exhibits graceful performance degradation as the server and/or switch failure rate increases. This property is of special importance for shipping-container data centers, since once the container is sealed and operational, it becomes very diﬃcult to repair or replace its components.},
	language = {en},
	author = {Guo, Chuanxiong and Lu, Guohan and Li, Dan and Wu, Haitao and Zhang, Xuan and Shi, Yunfeng and Tian, Chen and Zhang, Yongguang and Lu, Songwu},
	pages = {12},
	file = {Guo et al. - BCube a high performance, server-centric network .pdf:/home/vililipo/Zotero/storage/B4RJL6XF/Guo et al. - BCube a high performance, server-centric network .pdf:application/pdf}
}

@article{pai_flash:_nodate,
	title = {Flash: {An} {Efficient} and {Portable} {Web} {Server}},
	abstract = {This paper presents the design of a new Web server architecture called the asymmetric multi-process eventdriven (AMPED) architecture, and evaluates the performance of an implementation of this architecture, the Flash Web server. The Flash Web server combines the high performance of single-process event-driven servers on cached workloads with the performance of multiprocess and multi-threaded servers on disk-bound workloads. Furthermore, the Flash Web server is easily portable since it achieves these results using facilities available in all modern operating systems.},
	language = {en},
	author = {Pai, Vivek S and Druschel, Peter and Zwaenepoel, Willy},
	pages = {14},
	file = {Pai et al. - Flash An Efficient and Portable Web Server.pdf:/home/vililipo/Zotero/storage/HPGGC7AP/Pai et al. - Flash An Efficient and Portable Web Server.pdf:application/pdf}
}

@inproceedings{harji_comparing_2012,
	address = {Haifa, Israel},
	title = {Comparing high-performance multi-core web-server architectures},
	isbn = {978-1-4503-1448-0},
	url = {http://dl.acm.org/citation.cfm?doid=2367589.2367591},
	doi = {10.1145/2367589.2367591},
	abstract = {In this paper, we study how web-server architecture and implementation affect performance when trying to obtain high throughput on a 4-core system servicing static content. We focus on static content as a growing numbers of servers are dedicated to workloads comprised of songs, photos, software, and videos chunked for HTTP downloads. Two representative static-content workloads are used: one serviced entirely from the ﬁle-system cache and the other requires signiﬁcant disk I/O. We focus on 4-core systems as: 1) it is a widely used conﬁgurations in data-centers and cloud services, 2) recent studies show large SMP systems may operate more efﬁciently when subdivided into smaller subsystems, 3) understanding performance with a smaller number of cores is essential before scaling to a larger number of cores, 4) and 4-cores may be sufﬁcient for many web servers. Two high-performance web-servers, with event-driven (µserver) and pipelined (WatPipe) architectures, are developed and tested for a multi-core environment. By carefully implementing and tuning the two web-servers, both achieve performance comparable to running independent copies of the server on each processor (N-copy). The new web-servers achieve high throughput (4,000–6,000 Mbps) with 40,000 to 70,000 connects/second; performance in all cases is better than nginx, lighttpd, and Apache. We conclude that implementation and tuning of web servers is perhaps more important than server architecture. We also ﬁnd it is better to use blocking rather than non-blocking calls to sendﬁle, when the requested ﬁles do not all ﬁt in the ﬁle-system cache.},
	language = {en},
	urldate = {2019-03-27},
	booktitle = {Proceedings of the 5th {Annual} {International} {Systems} and {Storage} {Conference} on - {SYSTOR} '12},
	publisher = {ACM Press},
	author = {Harji, Ashif S. and Buhr, Peter A. and Brecht, Tim},
	year = {2012},
	pages = {1--12},
	file = {Harji et al. - 2012 - Comparing high-performance multi-core web-server a.pdf:/home/vililipo/Zotero/storage/Z69JCHNU/Harji et al. - 2012 - Comparing high-performance multi-core web-server a.pdf:application/pdf}
}

@article{praphamontripong_analytical_2007,
	title = {An {Analytical} {Approach} to {Performance} {Analysis} of an {Asynchronous} {Web} {Server}},
	volume = {83},
	issn = {0037-5497, 1741-3133},
	url = {http://journals.sagepub.com/doi/10.1177/0037549707080891},
	doi = {10.1177/0037549707080891},
	abstract = {Concurrency can be implemented in a Web server using synchronous or asynchronous mechanisms provided by the underlying operating system. Compared to the synchronous mechanisms, asynchronous mechanisms are attractive because they provide the benefit of concurrency while alleviating much of the overhead and complexity of multi-threading. The Proactor pattern in middleware, which encapsulates the asynchronous mechanisms provided by the operating system, can be used to implement a high performance Web server. The performance expectations imposed on a Web server make it necessary to analyze its performance prior to deployment. While the performance of a server can be measured after implementation, design-time performance analysis, conducted early in the life cycle, can enable informed configuration and provisioning choices. A model-based approach can be used for such design-time performance analysis. In this paper we present a performance model of the architecture of an asynchronous Web server which uses the Proactor pattern. We discuss the implementation of the performance model using the Stochastic Reward Net (SRN) modeling paradigm. A model decomposition strategy along with its SRN implementation to facilitate the application of the model to practical Web servers is then described. We demonstrate the use of the model to guide key provisioning and configuration decisions with several examples.},
	language = {en},
	number = {8},
	urldate = {2019-03-27},
	journal = {SIMULATION},
	author = {Praphamontripong, U. and Gokhale, S. and Gokhale, Aniruddha and Gray, Jeff},
	month = aug,
	year = {2007},
	pages = {571--586},
	file = {Praphamontripong et al. - 2007 - An Analytical Approach to Performance Analysis of .pdf:/home/vililipo/Zotero/storage/PBXEAVFH/Praphamontripong et al. - 2007 - An Analytical Approach to Performance Analysis of .pdf:application/pdf}
}

@article{praphamontripong_analytical_2007-1,
	title = {An {Analytical} {Approach} to {Performance} {Analysis} of an {Asynchronous} {Web} {Server}},
	volume = {83},
	issn = {0037-5497, 1741-3133},
	url = {http://journals.sagepub.com/doi/10.1177/0037549707080891},
	doi = {10.1177/0037549707080891},
	abstract = {Concurrency can be implemented in a Web server using synchronous or asynchronous mechanisms provided by the underlying operating system. Compared to the synchronous mechanisms, asynchronous mechanisms are attractive because they provide the benefit of concurrency while alleviating much of the overhead and complexity of multi-threading. The Proactor pattern in middleware, which encapsulates the asynchronous mechanisms provided by the operating system, can be used to implement a high performance Web server. The performance expectations imposed on a Web server make it necessary to analyze its performance prior to deployment. While the performance of a server can be measured after implementation, design-time performance analysis, conducted early in the life cycle, can enable informed configuration and provisioning choices. A model-based approach can be used for such design-time performance analysis. In this paper we present a performance model of the architecture of an asynchronous Web server which uses the Proactor pattern. We discuss the implementation of the performance model using the Stochastic Reward Net (SRN) modeling paradigm. A model decomposition strategy along with its SRN implementation to facilitate the application of the model to practical Web servers is then described. We demonstrate the use of the model to guide key provisioning and configuration decisions with several examples.},
	language = {en},
	number = {8},
	urldate = {2019-03-27},
	journal = {SIMULATION},
	author = {Praphamontripong, U. and Gokhale, S. and Gokhale, Aniruddha and Gray, Jeff},
	month = aug,
	year = {2007},
	pages = {571--586},
	file = {Praphamontripong et al. - 2007 - An Analytical Approach to Performance Analysis of .pdf:/home/vililipo/Zotero/storage/4WY4995M/Praphamontripong et al. - 2007 - An Analytical Approach to Performance Analysis of .pdf:application/pdf}
}

@article{pyarali_object_nodate,
	title = {An {Object} {Behavioral} {Pattern} for {Demultiplexing} and {Dispatching} {Handlers} for {Asynchronous} {Events}},
	abstract = {Modern operating systems provide multiple mechanisms for developing concurrent applications. Synchronous multithreading is a popular mechanism for developing applications that perform multiple operations simultaneously. However, threads often have high performance overhead and require deep knowledge of synchronization patterns and principles. Therefore, an increasing number of operating systems support asynchronous mechanisms that provide the beneﬁts of concurrency while alleviating much of the overhead and complexity of multi-threading.},
	language = {en},
	author = {Pyarali, Irfan and Harrison, Tim and Schmidt, Douglas C and Jordan, Thomas D},
	pages = {14},
	file = {Pyarali et al. - An Object Behavioral Pattern for Demultiplexing an.pdf:/home/vililipo/Zotero/storage/265RWKYH/Pyarali et al. - An Object Behavioral Pattern for Demultiplexing an.pdf:application/pdf}
}

@article{schmidt_reactor:_1995,
	title = {Reactor: {An} {Object} {Behavioral} {Pattern} for {Concurrent} {Event} {Demultiplexing} and {Dispatching}},
	shorttitle = {Reactor},
	abstract = {Factory design patterns [9]), and advanced operating system mechanisms (such as explicit dynamic linking and multi-threading [10]).  9 Sample Code  The following code illustrates an example of the Reactor object behavioral pattern. The example implements a portion of the logging server described in Section 2. This example also illustrates the use of an object creational pattern called the Accepter (described in [7]). The Accepter pattern decouples the act of establishing a connection from the service(s) provided once a connection is established. This pattern is useful for simplifying the development of connection-oriented network services (such as file transfer, remote login, distributed logging, and video-on-demand). The Accepter pattern enables the application-specific portion of a service to be modified independently of the mechanism used to establish the connection.  The code shown below implements the ClientAccepter class. This class performs the steps necessary to accept connecti...},
	author = {Schmidt, Douglas C.},
	year = {1995},
	file = {Citeseer - Full Text PDF:/home/vililipo/Zotero/storage/QRI64KF2/Schmidt - 1995 - Reactor An Object Behavioral Pattern for Concurre.pdf:application/pdf;Citeseer - Snapshot:/home/vililipo/Zotero/storage/7PD2GE5V/summary.html:text/html}
}

@article{sinha_client-server_1992,
	title = {Client-server computing},
	volume = {35},
	issn = {00010782},
	url = {http://portal.acm.org/citation.cfm?doid=129902.129908},
	doi = {10.1145/129902.129908},
	language = {en},
	number = {7},
	urldate = {2019-03-28},
	journal = {Communications of the ACM},
	author = {Sinha, Alok},
	month = jul,
	year = {1992},
	pages = {77--98},
	file = {Sinha - 1992 - Client-server computing.pdf:/home/vililipo/Zotero/storage/F3PT88VM/Sinha - 1992 - Client-server computing.pdf:application/pdf}
}

@misc{noauthor_design_nodate,
	title = {Design overview — libuv documentation},
	url = {http://docs.libuv.org/en/v1.x/design.html},
	urldate = {2019-03-28},
	file = {Design overview — libuv documentation:/home/vililipo/Zotero/storage/5J8RL67K/design.html:text/html}
}

@article{ling_analysis_2000,
	title = {Analysis of optimal thread pool size},
	volume = {34},
	issn = {01635980},
	url = {http://portal.acm.org/citation.cfm?doid=346152.346320},
	doi = {10.1145/346152.346320},
	abstract = {The success of e-commerce, messaging middleware, and other lnternet-based applications depends in part on the ability of network servers to respond in a timely and reliable manner to simultaneous service requests. Multithreaded systems, due to their efficient use of system resources and the popularity of shared-memory multi-processor architectures, have become the server implementation of choice. However, creating and destroying a thread is far from free, requiring run-time memory allocation and deallocation. These overheads become especially onerous during periods of high load and can be a major factor behind system slowdowns. A thread-pool architecture addresses this problem by prespawning and then managing a pool of threads. Threads in the pool are reused, so that thread creation and destruction overheads are incurred only once per thread, and not once per request. However, efficient thread management for a given system load highly depends on the thread pool size, which is currently determined heuristically. In this paper, we characterize several system resource costs associated with thread pool size. If the thread pool is too large, and threads go unused, then processing and memory resources are wasted maintaining the thread pool. If the thread pool is too small, then additional threads must be created and destroyed on the fly to handle new requests. We analytically determine the optimal thread pool size to maximize the expected gain of using a thread.},
	language = {en},
	number = {2},
	urldate = {2019-04-03},
	journal = {ACM SIGOPS Operating Systems Review},
	author = {Ling, Yibei and Mullen, Tracy and Lin, Xiaola},
	month = apr,
	year = {2000},
	pages = {42--55},
	file = {Ling et al. - 2000 - Analysis of optimal thread pool size.pdf:/home/vililipo/Zotero/storage/HYG48C4U/Ling et al. - 2000 - Analysis of optimal thread pool size.pdf:application/pdf}
}

@inproceedings{pariag_comparing_2007,
	address = {New York, NY, USA},
	series = {{EuroSys} '07},
	title = {Comparing the {Performance} of {Web} {Server} {Architectures}},
	isbn = {978-1-59593-636-3},
	url = {http://doi.acm.org/10.1145/1272996.1273021},
	doi = {10.1145/1272996.1273021},
	abstract = {In this paper, we extensively tune and then compare the performance of web servers based on three different server architectures. The μserver utilizes an event-driven architecture, Knot uses the highly-efficient Capriccio thread library to implement a thread-per-connection model, and WatPipe uses a hybrid of events and threads to implement a pipeline-based server that is similar in spirit to a staged event-driven architecture (SEDA) server like Haboob. We describe modifications made to the Capriccio thread library to use Linux's zero-copy sendfile interface. We then introduce the SY mmetric Multi-Processor Event Driven (SYMPED) architecture in which relatively minor modifications are made to a single process event-driven (SPED) server (the μserver) to allow it to continue processing requests in the presence of blocking due to disk accesses. Finally, we describe our C++ implementation of WatPipe, which although utilizing a pipeline-based architecture, excludes the dynamic controls over event queues and thread pools used in SEDA. When comparing the performance of these three server architectures on the workload used in our study, we arrive at different conclusions than previous studies. In spite of recent improvements to threading libraries and our further improvements to Capriccio and Knot, both the event-based μserver and pipeline-based Wat-Pipe server provide better throughput (by about 18\%). We also observe that when using blocking sockets to send data to clients, the performance obtained with some architectures is quite good and in one case is noticeably better than when using non-blocking sockets.},
	urldate = {2019-04-03},
	booktitle = {Proceedings of the 2Nd {ACM} {SIGOPS}/{EuroSys} {European} {Conference} on {Computer} {Systems} 2007},
	publisher = {ACM},
	author = {Pariag, David and Brecht, Tim and Harji, Ashif and Buhr, Peter and Shukla, Amol and Cheriton, David R.},
	year = {2007},
	note = {event-place: Lisbon, Portugal},
	keywords = {events, performance, scalability, threads, web servers},
	pages = {231--243},
	file = {ACM Full Text PDF:/home/vililipo/Zotero/storage/WZ7PIXBQ/Pariag et al. - 2007 - Comparing the Performance of Web Server Architectu.pdf:application/pdf}
}